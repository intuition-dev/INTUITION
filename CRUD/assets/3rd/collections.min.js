// v5.02.11 on 2019-03-19T10:34:53.267Z
!function(f) {
 if ("object" == typeof exports && "undefined" != typeof module) {
  module.exports = f();
 } else if ("function" == typeof define && define.amd) {
  define([], f);
 } else {
  ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).collections = f();
 }
}(function() {
 return function() {
  return function r(e, n, t) {
   function o(i, f) {
    if (!n[i]) {
     if (!e[i]) {
      var c = "function" == typeof require && require;
      if (!f && c) {
       return c(i, !0);
      }
      if (u) {
       return u(i, !0);
      }
      var a = new Error("Cannot find module '" + i + "'");
      throw a.code = "MODULE_NOT_FOUND", a;
     }
     var p = n[i] = {
      exports: {}
     };
     e[i][0].call(p.exports, function(r) {
      return o(e[i][1][r] || r);
     }, p, p.exports, r, e, n, t);
    }
    return n[i].exports;
   }
   for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
    o(t[i]);
   }
   return o;
  };
 }()({
  1: [ function(require, module, exports) {
   "use strict";
   require("./shim");
   var GenericCollection = require("./generic-collection"), GenericMap = require("./generic-map");
   function Dict(values, getDefault) {
    if (!(this instanceof Dict)) {
     return new Dict(values, getDefault);
    }
    getDefault = getDefault || Function.noop, this.getDefault = getDefault, this.store = Object.create(null), 
    this.length = 0, this.addEach(values);
   }
   module.exports = Dict, Dict.Dict = Dict, Object.addEach(Dict.prototype, GenericCollection.prototype), 
   Object.addEach(Dict.prototype, GenericMap.prototype), Dict.from = GenericCollection.from, 
   Dict.prototype.constructClone = function(values) {
    return new this.constructor(values, this.getDefault);
   }, Dict.prototype.assertString = function(key) {
    if ("string" != typeof key) {
     throw new TypeError("key must be a string but Got " + key);
    }
   }, Object.defineProperty(Dict.prototype, "$__proto__", {
    writable: !0
   }), Object.defineProperty(Dict.prototype, "_hasProto", {
    get: function() {
     return this.hasOwnProperty("$__proto__") && void 0 !== this._protoValue;
    }
   }), Object.defineProperty(Dict.prototype, "_protoValue", {
    get: function() {
     return this.$__proto__;
    },
    set: function(value) {
     this.$__proto__ = value;
    }
   }), Object.defineProperty(Dict.prototype, "size", GenericCollection._sizePropertyDescriptor), 
   Dict.prototype.get = function(key, defaultValue) {
    return this.assertString(key), "__proto__" === key ? this._hasProto ? this._protoValue : arguments.length > 1 ? defaultValue : this.getDefault(key) : key in this.store ? this.store[key] : arguments.length > 1 ? defaultValue : this.getDefault(key);
   }, Dict.prototype.set = function(key, value) {
    this.assertString(key);
    var isProtoKey = "__proto__" === key;
    return (isProtoKey ? this._hasProto : key in this.store) ? (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, isProtoKey ? this._protoValue : this.store[key]), 
    isProtoKey ? this._protoValue = value : this.store[key] = value, this.dispatchesMapChanges && this.dispatchMapChange(key, value), 
    !1) : (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, void 0), this.length++, 
    isProtoKey ? this._protoValue = value : this.store[key] = value, this.dispatchesMapChanges && this.dispatchMapChange(key, value), 
    !0);
   }, Dict.prototype.has = function(key) {
    return this.assertString(key), "__proto__" === key ? this._hasProto : key in this.store;
   }, Dict.prototype.delete = function(key) {
    return this.assertString(key), "__proto__" === key ? !!this._hasProto && (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, this._protoValue), 
    this._protoValue = void 0, this.length--, this.dispatchesMapChanges && this.dispatchMapChange(key, void 0), 
    !0) : key in this.store && (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, this.store[key]), 
    delete this.store[key], this.length--, this.dispatchesMapChanges && this.dispatchMapChange(key, void 0), 
    !0);
   }, Dict.prototype.clear = function() {
    var key;
    for (key in this._hasProto && (this.dispatchesMapChanges && this.dispatchBeforeMapChange("__proto__", this._protoValue), 
    this._protoValue = void 0, this.dispatchesMapChanges && this.dispatchMapChange("__proto__", void 0)), 
    this.store) {
     this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, this.store[key]), 
     delete this.store[key], this.dispatchesMapChanges && this.dispatchMapChange(key, void 0);
    }
    this.length = 0;
   }, Dict.prototype.reduce = function(callback, basis, thisp) {
    this._hasProto && (basis = callback.call(thisp, basis, "$__proto__", "__proto__", this));
    var store = this.store;
    for (var key in this.store) {
     basis = callback.call(thisp, basis, store[key], key, this);
    }
    return basis;
   }, Dict.prototype.reduceRight = function(callback, basis, thisp) {
    var self = this, store = this.store;
    return basis = Object.keys(this.store).reduceRight(function(basis, key) {
     return callback.call(thisp, basis, store[key], key, self);
    }, basis), this._hasProto ? callback.call(thisp, basis, this._protoValue, "__proto__", self) : basis;
   }, Dict.prototype.one = function() {
    var key;
    for (key in this.store) {
     return this.store[key];
    }
    return this._protoValue;
   }, Dict.prototype.toJSON = function() {
    return this.toObject();
   };
  }, {
   "./generic-collection": 9,
   "./generic-map": 10,
   "./shim": 28
  } ],
  2: [ function(require, module, exports) {
   "use strict";
   require("./shim");
   var Dict = require("./_dict"), List = require("./_list"), GenericCollection = require("./generic-collection"), GenericSet = require("./generic-set"), TreeLog = require("./tree-log");
   Object.prototype.hasOwnProperty;
   function FastSet(values, equals, hash, getDefault) {
    if (!(this instanceof FastSet)) {
     return new FastSet(values, equals, hash, getDefault);
    }
    equals = equals || Object.equals, hash = hash || Object.hash, getDefault = getDefault || Function.noop, 
    this.contentEquals = equals, this.contentHash = hash, this.getDefault = getDefault;
    var self = this;
    this.buckets = new this.Buckets(null, function getDefaultBucket() {
     return new self.Bucket();
    }), this.length = 0, this.addEach(values);
   }
   module.exports = FastSet, FastSet.FastSet = FastSet, Object.addEach(FastSet.prototype, GenericCollection.prototype), 
   Object.addEach(FastSet.prototype, GenericSet.prototype), FastSet.from = GenericCollection.from, 
   FastSet.prototype.Buckets = Dict, FastSet.prototype.Bucket = List, FastSet.prototype.constructClone = function(values) {
    return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);
   }, FastSet.prototype.has = function(value) {
    var hash = this.contentHash(value);
    return this.buckets.get(hash).has(value);
   }, FastSet.prototype.get = function(value, equals) {
    if (equals) {
     throw new Error("FastSet#get does not support second argument: equals");
    }
    var hash = this.contentHash(value), buckets = this.buckets;
    return buckets.has(hash) ? buckets.get(hash).get(value) : this.getDefault(value);
   }, FastSet.prototype.delete = function(value, equals) {
    if (equals) {
     throw new Error("FastSet#delete does not support second argument: equals");
    }
    var hash = this.contentHash(value), buckets = this.buckets;
    if (buckets.has(hash)) {
     var bucket = buckets.get(hash);
     if (bucket.delete(value)) {
      return this.length--, 0 === bucket.length && buckets.delete(hash), !0;
     }
    }
    return !1;
   }, FastSet.prototype.clear = function() {
    this.buckets.clear(), this.length = 0;
   }, FastSet.prototype.add = function(value) {
    var hash = this.contentHash(value), buckets = this.buckets;
    return buckets.has(hash) || buckets.set(hash, new this.Bucket(null, this.contentEquals)), 
    !buckets.get(hash).has(value) && (buckets.get(hash).add(value), this.length++, !0);
   }, FastSet.prototype.reduce = function(callback, basis) {
    var thisp = arguments[2], index = 0;
    return this.buckets.reduce(function(basis, bucket) {
     return bucket.reduce(function(basis, value) {
      return callback.call(thisp, basis, value, index++, this);
     }, basis, this);
    }, basis, this);
   }, FastSet.prototype.one = function() {
    if (this.length > 0) {
     return this.buckets.one().one();
    }
   }, FastSet.prototype.iterate = function() {
    return this.buckets.valuesArray().flatten().iterate();
   }, FastSet.prototype.log = function(charmap, logNode, callback, thisp) {
    charmap = charmap || TreeLog.unicodeSharp, logNode = logNode || this.logNode, callback || (callback = console.log, 
    thisp = console), callback = callback.bind(thisp);
    for (var hash, branch, leader, bucket, buckets = this.buckets, bucketsSize = buckets.size, mapIter = buckets.keys(), index = 0; hash = mapIter.next().value; ) {
     index === bucketsSize - 1 ? (branch = charmap.fromAbove, leader = ' ') : 0 === index ? (branch = charmap.branchDown, 
     leader = charmap.strafe) : (branch = charmap.fromBoth, leader = charmap.strafe), 
     bucket = buckets.get(hash), callback.call(thisp, branch + charmap.through + charmap.branchDown + ' ' + hash), 
     bucket.forEach(function(value, node) {
      var branch, below, written;
      node === bucket.head.prev ? (branch = charmap.fromAbove, below = ' ') : (branch = charmap.fromBoth, 
      below = charmap.strafe), logNode(node, function(line) {
       written ? callback.call(thisp, leader + ' ' + below + '  ' + line) : (callback.call(thisp, leader + ' ' + branch + charmap.through + charmap.through + line), 
       written = !0);
      }, function(line) {
       callback.call(thisp, leader + ' ' + charmap.strafe + '  ' + line);
      });
     }), index++;
    }
   }, FastSet.prototype.logNode = function(node, write) {
    var value = node.value;
    Object(value) === value ? JSON.stringify(value, null, 4).split("\n").forEach(function(line) {
     write(" " + line);
    }) : write(" " + value);
   };
  }, {
   "./_dict": 1,
   "./_list": 3,
   "./generic-collection": 9,
   "./generic-set": 12,
   "./shim": 28,
   "./tree-log": 34
  } ],
  3: [ function(require, module, exports) {
   "use strict";
   module.exports = List;
   require("./shim");
   var GenericCollection = require("./generic-collection"), GenericOrder = require("./generic-order");
   function List(values, equals, getDefault) {
    return List._init(List, this, values, equals, getDefault);
   }
   function ListIterator(head) {
    this.head = head, this.at = head.next;
   }
   function Node(value) {
    this.value = value, this.prev = null, this.next = null;
   }
   List._init = function(constructor, object, values, equals, getDefault) {
    if (!(object instanceof constructor)) {
     return new constructor(values, equals, getDefault);
    }
    var head = object.head = new object.Node();
    head.next = head, head.prev = head, object.contentEquals = equals || Object.equals, 
    object.getDefault = getDefault || Function.noop, object.length = 0, object.addEach(values);
   }, List.List = List, Object.addEach(List.prototype, GenericCollection.prototype), 
   Object.addEach(List.prototype, GenericOrder.prototype), List.from = GenericCollection.from, 
   List.prototype.constructClone = function(values) {
    return new this.constructor(values, this.contentEquals, this.getDefault);
   }, List.prototype.find = function(value, equals, index) {
    equals = equals || this.contentEquals;
    for (var head = this.head, at = this.scan(index, head.next); at !== head; ) {
     if (equals(at.value, value)) {
      return at;
     }
     at = at.next;
    }
   }, List.prototype.findLast = function(value, equals, index) {
    equals = equals || this.contentEquals;
    for (var head = this.head, at = this.scan(index, head.prev); at !== head; ) {
     if (equals(at.value, value)) {
      return at;
     }
     at = at.prev;
    }
   }, List.prototype.has = function(value, equals) {
    return !!this.find(value, equals);
   }, List.prototype.get = function(value, equals) {
    var found = this.find(value, equals);
    return found ? found.value : this.getDefault(value);
   }, List.prototype.delete = function(value, equals) {
    var found = this.findLast(value, equals);
    return !!found && (found.delete(), this.length--, !0);
   }, List.prototype.deleteAll = function(value, equals) {
    equals = equals || this.contentEquals;
    for (var head = this.head, at = head.next, count = 0; at !== head; ) {
     equals(value, at.value) && (at.delete(), count++), at = at.next;
    }
    return this.length -= count, count;
   }, List.prototype.clear = function() {
    this.head.next = this.head.prev = this.head, this.length = 0;
   }, List.prototype.add = function(value) {
    var node = new this.Node(value);
    return this._addNode(node);
   }, List.prototype._addNode = function(node) {
    return this.head.addBefore(node), this.length++, !0;
   }, List.prototype.push = function() {
    for (var head = this.head, i = 0; i < arguments.length; i++) {
     var value = arguments[i], node = new this.Node(value);
     head.addBefore(node);
    }
    this.length += arguments.length;
   }, List.prototype.unshift = function() {
    for (var at = this.head, i = 0; i < arguments.length; i++) {
     var value = arguments[i], node = new this.Node(value);
     at.addAfter(node), at = node;
    }
    this.length += arguments.length;
   }, List.prototype._shouldPop = function() {
    var value, head = this.head;
    return head.prev !== head && (value = head.prev.value), value;
   }, List.prototype.pop = function(_before, _after) {
    var value, head = this.head;
    if (head.prev !== head) {
     value = head.prev.value;
     var index = this.length - 1, popDispatchValueArray = _before ? _before.call(this, value, index) : void 0;
     head.prev.delete(), this.length--, _after && _after.call(this, value, index, popDispatchValueArray);
    }
    return value;
   }, List.prototype.shift = function(_before, _after) {
    var value, head = this.head;
    if (head.prev !== head) {
     value = head.next.value;
     var dispatchValueArray = _before ? _before.call(this, value, 0) : void 0;
     head.next.delete(), this.length--, _after && _after.call(this, value, 0, dispatchValueArray);
    }
    return value;
   }, List.prototype.peek = function() {
    if (this.head !== this.head.next) {
     return this.head.next.value;
    }
   }, List.prototype.poke = function(value) {
    this.head !== this.head.next ? this.head.next.value = value : this.push(value);
   }, List.prototype.one = function() {
    return this.peek();
   }, List.prototype.scan = function(at, fallback) {
    var head = this.head;
    if ("number" == typeof at) {
     var count = at;
     if (count >= 0) {
      for (at = head.next; count && (count--, (at = at.next) != head); ) {}
     } else {
      for (at = head; count < 0 && (count++, (at = at.prev) != head); ) {}
     }
     return at;
    }
    return at || fallback;
   }, List.prototype.slice = function(at, end) {
    var sliced = [], head = this.head;
    for (at = this.scan(at, head.next), end = this.scan(end, head); at !== end && at !== head; ) {
     sliced.push(at.value), at = at.next;
    }
    return sliced;
   }, List.prototype.splice = function(at, length) {
    return this.swap(at, length, Array.prototype.slice.call(arguments, 2));
   }, List.prototype.swap = function(start, length, plus, _before, _after) {
    var initial = start;
    start = this.scan(start, this.head), null == length && (length = 1 / 0), plus = Array.from(plus);
    for (var minus = [], at = start; length-- && length >= 0 && at !== this.head; ) {
     minus.push(at.value), at = at.next;
    }
    _before && _before.call(this, start, plus, minus);
    at = start;
    var i = 0;
    for (at = start; i < minus.length; i++, at = at.next) {
     at.delete();
    }
    null == initial && at === this.head && (at = this.head.next);
    for (i = 0; i < plus.length; i++) {
     var node = new this.Node(plus[i]);
     at.addBefore(node);
    }
    return this.length += plus.length - minus.length, _after && _after.call(this, start, plus, minus), 
    minus;
   }, List.prototype.reverse = function() {
    var at = this.head;
    do {
     var temp = at.next;
     at.next = at.prev, at.prev = temp, at = at.next;
    } while (at !== this.head);
    return this;
   }, List.prototype.sort = function() {
    this.swap(0, this.length, this.sorted.apply(this, arguments));
   }, List.prototype.reduce = function(callback, basis) {
    for (var thisp = arguments[2], head = this.head, at = head.next; at !== head; ) {
     basis = callback.call(thisp, basis, at.value, at, this), at = at.next;
    }
    return basis;
   }, List.prototype.reduceRight = function(callback, basis) {
    for (var thisp = arguments[2], head = this.head, at = head.prev; at !== head; ) {
     basis = callback.call(thisp, basis, at.value, at, this), at = at.prev;
    }
    return basis;
   }, List.prototype.updateIndexes = function(node, index) {
    for (;node !== this.head; ) {
     node.index = index++, node = node.next;
    }
   }, List.prototype.iterate = function() {
    return new ListIterator(this.head);
   }, ListIterator.prototype.__iterationObject = null, Object.defineProperty(ListIterator.prototype, "_iterationObject", {
    get: function() {
     return this.__iterationObject || (this.__iterationObject = {
      done: !1,
      value: null
     });
    }
   }), ListIterator.prototype.next = function() {
    if (this.at === this.head) {
     this._iterationObject.done = !0, this._iterationObject.value = void 0;
    } else {
     var value = this.at.value;
     this.at = this.at.next, this._iterationObject.value = value;
    }
    return this._iterationObject;
   }, List.prototype.Node = Node, Node.prototype.delete = function() {
    this.prev.next = this.next, this.next.prev = this.prev;
   }, Node.prototype.addBefore = function(node) {
    var prev = this.prev;
    this.prev = node, node.prev = prev, prev.next = node, node.next = this;
   }, Node.prototype.addAfter = function(node) {
    var next = this.next;
    this.next = node, node.next = next, next.prev = node, node.prev = this;
   };
  }, {
   "./generic-collection": 9,
   "./generic-order": 11,
   "./shim": 28
  } ],
  4: [ function(require, module, exports) {
   (function(global) {
    "use strict";
    require("./shim");
    var Map, GlobalMap, CollectionsMap, GenericCollection = require("./generic-collection");
    if (void 0 !== global.Map && "function" == typeof global.Set.prototype.values) {
     var map_makeObservable;
     GlobalMap = Map = module.exports = global.Map, Map.Map = Map, map_makeObservable = {}.__proto__ === Object.prototype ? function() {
      this.__proto__ = ChangeDispatchMap;
     } : function() {
      Object.defineProperties(this, observableSetProperties);
     }, Object.defineProperty(Map.prototype, "makeObservable", {
      value: map_makeObservable,
      writable: !0,
      configurable: !0,
      enumerable: !1
     }), Object.defineProperty(Map.prototype, "makePropertyObservable", {
      value: function() {},
      writable: !0,
      configurable: !0,
      enumerable: !1
     }), Map.prototype.constructClone = function(values) {
      return new this.constructor(values);
     }, Map.prototype.isMap = !0, Map.prototype.addEach = function(values) {
      if (values && Object(values) === values) {
       if ("function" == typeof values.forEach) {
        !0 === values.isMap ? values.forEach(function(value, key) {
         this.set(key, value);
        }, this) : values.forEach(function(pair) {
         this.set(pair[0], pair[1]);
        }, this);
       } else if ("number" == typeof values.length) {
        for (var i = 0; i < values.length; i++) {
         this.add(values[i], i);
        }
       } else {
        Object.keys(values).forEach(function(key) {
         this.set(key, values[key]);
        }, this);
       }
      } else if (values && "number" == typeof values.length) {
       for (i = 0; i < values.length; i++) {
        this.add(values[i], i);
       }
      }
      return this;
     }, Map.prototype.add = function(value, key) {
      return this.set(key, value);
     }, Map.prototype.reduce = function(callback, basis) {
      var thisp = arguments[2];
      return this.forEach(function(value, key, map) {
       basis = callback.call(thisp, basis, value, key, this);
      }), basis;
     }, Map.prototype.reduceRight = function(callback, basis) {
      for (var aKey, thisp = arguments[2], keysIterator = this.keys(), size = this.size, reverseOrder = new Array(this.size), i = 0; aKey = keysIterator.next().value; ) {
       reverseOrder[--size] = aKey;
      }
      for (;i++ < size; ) {
       basis = callback.call(thisp, basis, this.get(reverseOrder[i]), reverseOrder[i], this);
      }
      return basis;
     }, Map.prototype.equals = function(that, equals) {
      return equals = equals || Object.equals, this === that || (that && "function" == typeof that.every ? that.size === this.size && that.every(function(value, key) {
       return equals(this.get(key), value);
      }, this) : Object.keys(that).length === this.size && Object.keys(that).every(function(key) {
       return equals(this.get(key), that[key]);
      }, this));
     };
     var _keysArrayFunction = function(value, key) {
      return key;
     };
     Map.prototype.keysArray = function() {
      return this.map(_keysArrayFunction);
     };
     var _valuesArrayFunction = function(value, key) {
      return value;
     };
     Map.prototype.valuesArray = function() {
      return this.map(_valuesArrayFunction);
     };
     var _entriesArrayFunction = function(value, key) {
      return [ key, value ];
     };
     Map.prototype.entriesArray = function() {
      return this.map(_entriesArrayFunction);
     }, Map.prototype.toJSON = function() {
      return this.entriesArray();
     }, Map.prototype.items = function() {
      return this.entriesArray();
     }, Map.from = function(value) {
      var result = new this();
      return result.addEach(value), result;
     }, Object.defineProperty(Map.prototype, "length", {
      get: function() {
       return this.size;
      },
      enumerable: !0,
      configurable: !0
     });
     var map_clear = Map.prototype.clear, map_set = Map.prototype.set, map_delete = Map.prototype.delete, observableMapProperties = {
      clear: {
       value: function() {
        var keys;
        this.dispatchesMapChanges && (this.forEach(function(value, key) {
         this.dispatchBeforeMapChange(key, value);
        }, this), keys = this.keysArray()), map_clear.call(this), this.dispatchesMapChanges && keys.forEach(function(key) {
         this.dispatchMapChange(key);
        }, this);
       },
       writable: !0,
       configurable: !0
      },
      set: {
       value: function(key, value) {
        var found = this.get(key);
        return found ? (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, found), 
        map_set.call(this, key, value), this.dispatchesMapChanges && this.dispatchMapChange(key, value)) : (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, void 0), 
        map_set.call(this, key, value), this.dispatchesMapChanges && this.dispatchMapChange(key, value)), 
        this;
       },
       writable: !0,
       configurable: !0
      },
      delete: {
       value: function(key) {
        return !!this.has(key) && (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, this.get(key)), 
        map_delete.call(this, key), this.dispatchesMapChanges && this.dispatchMapChange(key, void 0), 
        !0);
       }
      }
     };
     Object.addEach(Map.prototype, GenericCollection.prototype, !1);
     var ChangeDispatchMap = Object.create(Map.prototype, observableMapProperties);
    }
    var Set = require("./_set").CollectionsSet, GenericMap = require("./generic-map");
    CollectionsMap = Map = function Map(values, equals, hash, getDefault) {
     if (!(this instanceof Map)) {
      return new Map(values, equals, hash, getDefault);
     }
     equals = equals || Object.equals, hash = hash || Object.hash, getDefault = getDefault || Function.noop, 
     this.contentEquals = equals, this.contentHash = hash, this.getDefault = getDefault, 
     this.store = new Set(void 0, function keysEqual(a, b) {
      return equals(a.key, b.key);
     }, function keyHash(item) {
      return hash(item.key);
     }), this.length = 0, this.addEach(values);
    }, Map.Map = Map, Object.addEach(Map.prototype, GenericCollection.prototype), Object.addEach(Map.prototype, GenericMap.prototype), 
    Object.defineProperty(Map.prototype, "size", GenericCollection._sizePropertyDescriptor), 
    Map.from = GenericCollection.from, Map.prototype.constructClone = function(values) {
     return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);
    }, Map.prototype.log = function(charmap, logNode, callback, thisp) {
     logNode = logNode || this.logNode, this.store.log(charmap, function(node, log, logBefore) {
      logNode(node.value.value, log, logBefore);
     }, callback, thisp);
    }, Map.prototype.logNode = function(node, log) {
     log(' key: ' + node.key), log(' value: ' + node.value);
    }, GlobalMap ? (module.exports = GlobalMap, GlobalMap.CollectionsMap = CollectionsMap) : module.exports = CollectionsMap;
   }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
  }, {
   "./_set": 5,
   "./generic-collection": 9,
   "./generic-map": 10,
   "./shim": 28
  } ],
  5: [ function(require, module, exports) {
   (function(global) {
    "use strict";
    require("./shim");
    var GlobalSet, CollectionsSet, GenericCollection = require("./generic-collection"), GenericSet = require("./generic-set");
    void 0 !== global.Set && "function" == typeof global.Set.prototype.values && ((GlobalSet = module.exports = global.Set).Set = GlobalSet, 
    GlobalSet.prototype.reduce = function(callback, basis) {
     var thisp = arguments[2];
     return this.forEach(function(value) {
      basis = callback.call(thisp, basis, value, this);
     }), basis;
    }, GlobalSet.prototype.reduceRight = function(callback, basis) {
     for (var value, thisp = arguments[2], setIterator = this.values(), size = this.size, reverseOrder = new Array(this.size), i = size; value = setIterator.next().value; ) {
      reverseOrder[--i] = value;
     }
     for (;i < size; ) {
      basis = callback.call(thisp, basis, reverseOrder[i++], this);
     }
     return basis;
    }, GlobalSet.prototype.equals = function(that, equals) {
     var self = this;
     return that && "function" == typeof that.reduce && this.size === (that.size || that.length) && that.reduce(function(equal, value) {
      return equal && self.has(value, equals);
     }, !0);
    }, GlobalSet.prototype.constructClone = function(values) {
     return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);
    }, GlobalSet.prototype.toJSON = function() {
     return this.entriesArray();
    }, GlobalSet.prototype.one = function() {
     if (this.size > 0) {
      return this.values().next().value;
     }
    }, GlobalSet.prototype.pop = function() {
     if (this.size) {
      for (var aValue, value, setIterator = this.values(); aValue = setIterator.next().value; ) {
       value = aValue;
      }
      return this.delete(value, this.size - 1), value;
     }
    }, GlobalSet.prototype.shift = function() {
     if (this.size) {
      var firstValue = this.values().next().value;
      return this.delete(firstValue, 0), firstValue;
     }
    }, Object.defineProperty(GlobalSet.prototype, "length", {
     get: function() {
      return this.size;
     },
     enumerable: !0,
     configurable: !0
    }), GlobalSet.from = function(value) {
     var result = new this();
     return result.addEach(value), result;
    }, Object.addEach(GlobalSet.prototype, GenericCollection.prototype, !1), Object.addEach(GlobalSet.prototype, GenericSet.prototype, !1));
    var List = require("./_list"), FastSet = require("./_fast-set"), Iterator = require("./iterator");
    (CollectionsSet = function CollectionsSet(values, equals, hash, getDefault) {
     return CollectionsSet._init(CollectionsSet, this, values, equals, hash, getDefault);
    })._init = function(constructor, object, values, equals, hash, getDefault) {
     if (!(object instanceof constructor)) {
      return new constructor(values, equals, hash, getDefault);
     }
     equals = equals || Object.equals, hash = hash || Object.hash, getDefault = getDefault || Function.noop, 
     object.contentEquals = equals, object.contentHash = hash, object.getDefault = getDefault, 
     object.order = new object.Order(void 0, equals), object.store = new object.Store(void 0, function(a, b) {
      return equals(a.value, b.value);
     }, function(node) {
      return hash(node.value);
     }), object.length = 0, object.addEach(values);
    }, CollectionsSet.Set = CollectionsSet, CollectionsSet.CollectionsSet = CollectionsSet, 
    Object.addEach(CollectionsSet.prototype, GenericCollection.prototype), Object.addEach(CollectionsSet.prototype, GenericSet.prototype), 
    CollectionsSet.from = GenericCollection.from, Object.defineProperty(CollectionsSet.prototype, "size", GenericCollection._sizePropertyDescriptor), 
    CollectionsSet.prototype.Order = List, CollectionsSet.prototype.Store = FastSet, 
    CollectionsSet.prototype.constructClone = function(values) {
     return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);
    }, CollectionsSet.prototype.has = function(value) {
     var node = new this.order.Node(value);
     return this.store.has(node);
    }, CollectionsSet.prototype.get = function(value, equals) {
     if (equals) {
      throw new Error("Set#get does not support second argument: equals");
     }
     var node = new this.order.Node(value);
     return (node = this.store.get(node)) ? node.value : this.getDefault(value);
    }, CollectionsSet.prototype.add = function(value) {
     var node = new this.order.Node(value);
     if (!this.store.has(node)) {
      this.length;
      return this.order.add(value), node = this.order.head.prev, this.store.add(node), 
      this.length++, !0;
     }
     return !1;
    }, CollectionsSet.prototype.delete = function(value, equals) {
     if (equals) {
      throw new Error("Set#delete does not support second argument: equals");
     }
     var node = new this.order.Node(value);
     return !!this.store.has(node) && (node = this.store.get(node), this.store.delete(node), 
     this.order.splice(node, 1), this.length--, !0);
    }, CollectionsSet.prototype.pop = function() {
     if (this.length) {
      var result = this.order.head.prev.value;
      return this.delete(result), result;
     }
    }, CollectionsSet.prototype.shift = function() {
     if (this.length) {
      var result = this.order.head.next.value;
      return this.delete(result), result;
     }
    }, CollectionsSet.prototype.one = function() {
     if (this.length > 0) {
      return this.store.one().value;
     }
    }, CollectionsSet.prototype.clear = function() {
     this.store.clear(), this.order.clear(), this.length = 0;
    }, Object.defineProperty(CollectionsSet.prototype, "_clear", {
     value: CollectionsSet.prototype.clear
    }), CollectionsSet.prototype.reduce = function(callback, basis) {
     var thisp = arguments[2], index = 0;
     return this.order.reduce(function(basis, value) {
      return callback.call(thisp, basis, value, index++, this);
     }, basis, this);
    }, CollectionsSet.prototype.reduceRight = function(callback, basis) {
     var thisp = arguments[2], list = this.order, index = this.length - 1;
     return list.reduceRight(function(basis, value) {
      return callback.call(thisp, basis, value, index--, this);
     }, basis, this);
    }, CollectionsSet.prototype.iterate = function() {
     return this.order.iterate();
    }, CollectionsSet.prototype.values = function() {
     return new Iterator(this.valuesArray());
    }, CollectionsSet.prototype.log = function() {
     var set = this.store;
     return set.log.apply(set, arguments);
    }, GlobalSet ? (GlobalSet.prototype.valuesArray = GenericSet.prototype.valuesArray, 
    GlobalSet.prototype.entriesArray = GenericSet.prototype.entriesArray, module.exports = GlobalSet, 
    GlobalSet.CollectionsSet = CollectionsSet) : module.exports = CollectionsSet;
   }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
  }, {
   "./_fast-set": 2,
   "./_list": 3,
   "./generic-collection": 9,
   "./generic-set": 12,
   "./iterator": 13,
   "./shim": 28
  } ],
  6: [ function(require, module, exports) {
   "use strict";
   var Dict = require("./_dict"), PropertyChanges = require("./listen/property-changes"), MapChanges = require("./listen/map-changes");
   module.exports = Dict, Object.addEach(Dict.prototype, PropertyChanges.prototype), 
   Object.addEach(Dict.prototype, MapChanges.prototype);
  }, {
   "./_dict": 1,
   "./listen/map-changes": 16,
   "./listen/property-changes": 17
  } ],
  7: [ function(require, module, exports) {
   "use strict";
   require("./shim");
   var Set = require("./fast-set"), GenericCollection = require("./generic-collection"), GenericMap = require("./generic-map"), PropertyChanges = require("./listen/property-changes"), MapChanges = require("./listen/map-changes");
   function FastMap(values, equals, hash, getDefault) {
    if (!(this instanceof FastMap)) {
     return new FastMap(values, equals, hash, getDefault);
    }
    equals = equals || Object.equals, hash = hash || Object.hash, getDefault = getDefault || Function.noop, 
    this.contentEquals = equals, this.contentHash = hash, this.getDefault = getDefault, 
    this.store = new Set(void 0, function keysEqual(a, b) {
     return equals(a.key, b.key);
    }, function keyHash(item) {
     return hash(item.key);
    }), this.length = 0, this.addEach(values);
   }
   module.exports = FastMap, FastMap.FastMap = FastMap, Object.addEach(FastMap.prototype, GenericCollection.prototype), 
   Object.addEach(FastMap.prototype, GenericMap.prototype), Object.addEach(FastMap.prototype, PropertyChanges.prototype), 
   Object.addEach(FastMap.prototype, MapChanges.prototype), FastMap.from = GenericCollection.from, 
   FastMap.prototype.constructClone = function(values) {
    return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);
   }, FastMap.prototype.log = function(charmap, stringify) {
    stringify = stringify || this.stringify, this.store.log(charmap, stringify);
   }, FastMap.prototype.stringify = function(item, leader) {
    return leader + JSON.stringify(item.key) + ": " + JSON.stringify(item.value);
   };
  }, {
   "./fast-set": 8,
   "./generic-collection": 9,
   "./generic-map": 10,
   "./listen/map-changes": 16,
   "./listen/property-changes": 17,
   "./shim": 28
  } ],
  8: [ function(require, module, exports) {
   "use strict";
   require("./shim");
   var FastSet = require("./_fast-set"), PropertyChanges = require("./listen/property-changes");
   module.exports = FastSet, Object.addEach(FastSet.prototype, PropertyChanges.prototype);
  }, {
   "./_fast-set": 2,
   "./listen/property-changes": 17,
   "./shim": 28
  } ],
  9: [ function(require, module, exports) {
   (function(global) {
    "use strict";
    function GenericCollection() {
     throw new Error("Can't construct. GenericCollection is a mixin.");
    }
    module.exports = GenericCollection;
    var DOMTokenList = global.DOMTokenList || function() {};
    GenericCollection.EmptyArray = Object.freeze([]), GenericCollection.prototype.addEach = function(values) {
     if (values && (values instanceof Array || values instanceof DOMTokenList || values instanceof String)) {
      for (var i = 0; i < values.length; i++) {
       this.add(values[i], i);
      }
     } else if (values && Object(values) === values) {
      if ("function" == typeof values.forEach) {
       values.forEach(this.add, this);
      } else if ("number" == typeof values.length) {
       for (i = 0; i < values.length; i++) {
        this.add(values[i], i);
       }
      } else {
       Object.keys(values).forEach(function(key) {
        this.add(values[key], key);
       }, this);
      }
     }
     return this;
    }, GenericCollection.prototype.deleteEach = function(values, equals) {
     return values.forEach(function(value) {
      this.delete(value, equals);
     }, this), this;
    }, GenericCollection.prototype.forEach = function(callback) {
     var thisp = arguments[1];
     return this.reduce(function(undefined, value, key, object, depth) {
      callback.call(thisp, value, key, object, depth);
     }, void 0);
    }, GenericCollection.prototype.map = function(callback) {
     var thisp = arguments[1], result = [];
     return this.reduce(function(undefined, value, key, object, depth) {
      result.push(callback.call(thisp, value, key, object, depth));
     }, void 0), result;
    }, GenericCollection.prototype.enumerate = function(start) {
     null == start && (start = 0);
     var result = [];
     return this.reduce(function(undefined, value) {
      result.push([ start++, value ]);
     }, void 0), result;
    }, GenericCollection.prototype.group = function(callback, thisp, equals) {
     equals = equals || Object.equals;
     var groups = [], keys = [];
     return this.forEach(function(value, key, object) {
      key = callback.call(thisp, value, key, object);
      var group, index = keys.indexOf(key, equals);
      -1 === index ? (group = [], groups.push([ key, group ]), keys.push(key)) : group = groups[index][1], 
      group.push(value);
     }), groups;
    }, GenericCollection.prototype.toArray = function() {
     return this.map(Function.identity);
    }, GenericCollection.prototype.toObject = function() {
     var object = {};
     return this.reduce(function(undefined, value, key) {
      object[key] = value;
     }, void 0), object;
    }, GenericCollection.from = function() {
     return this.apply(this, arguments);
    }, GenericCollection.prototype.filter = function(callback) {
     var thisp = arguments[1], result = this.constructClone();
     return this.reduce(function(undefined, value, key, object, depth) {
      callback.call(thisp, value, key, object, depth) && result.add(value, key);
     }, void 0), result;
    }, GenericCollection.prototype.every = function(callback) {
     var thisp = arguments[1];
     return this.reduce(function(result, value, key, object, depth) {
      return result && callback.call(thisp, value, key, object, depth);
     }, !0);
    }, GenericCollection.prototype.some = function(callback) {
     var thisp = arguments[1];
     return this.reduce(function(result, value, key, object, depth) {
      return result || callback.call(thisp, value, key, object, depth);
     }, !1);
    }, GenericCollection.prototype.all = function() {
     return this.every(Boolean);
    }, GenericCollection.prototype.any = function() {
     return this.some(Boolean);
    }, GenericCollection.prototype.min = function(compare) {
     compare = compare || this.contentCompare || Object.compare;
     var first = !0;
     return this.reduce(function(result, value) {
      return first ? (first = !1, value) : compare(value, result) < 0 ? value : result;
     }, void 0);
    }, GenericCollection.prototype.max = function(compare) {
     compare = compare || this.contentCompare || Object.compare;
     var first = !0;
     return this.reduce(function(result, value) {
      return first ? (first = !1, value) : compare(value, result) > 0 ? value : result;
     }, void 0);
    }, GenericCollection.prototype.sum = function(zero) {
     return zero = void 0 === zero ? 0 : zero, this.reduce(function(a, b) {
      return a + b;
     }, zero);
    }, GenericCollection.prototype.average = function(zero) {
     var sum = void 0 === zero ? 0 : zero, count = void 0 === zero ? 0 : zero;
     return this.reduce(function(undefined, value) {
      sum += value, count += 1;
     }, void 0), sum / count;
    }, GenericCollection.prototype.concat = function() {
     for (var result = this.constructClone(this), i = 0; i < arguments.length; i++) {
      result.addEach(arguments[i]);
     }
     return result;
    }, GenericCollection.prototype.flatten = function() {
     var self = this;
     return this.reduce(function(result, array) {
      return array.forEach(function(value) {
       this.push(value);
      }, result, self), result;
     }, []);
    }, GenericCollection.prototype.zip = function() {
     var table = Array.prototype.slice.call(arguments);
     return table.unshift(this), Array.unzip(table);
    }, GenericCollection.prototype.join = function(delimiter) {
     return this.reduce(function(result, string) {
      return void 0 === result ? string : result + delimiter + string;
     }, void 0);
    }, GenericCollection.prototype.sorted = function(compare, by, order) {
     return (compare = compare || this.contentCompare || Object.compare).by ? (by = compare.by, 
     compare = compare.compare || this.contentCompare || Object.compare) : by = by || Function.identity, 
     void 0 === order && (order = 1), this.map(function(item) {
      return {
       by: by(item),
       value: item
      };
     }).sort(function(a, b) {
      return compare(a.by, b.by) * order;
     }).map(function(pair) {
      return pair.value;
     });
    }, GenericCollection.prototype.reversed = function() {
     return this.constructClone(this).reverse();
    }, GenericCollection.prototype.clone = function(depth, memo) {
     if (void 0 === depth) {
      depth = 1 / 0;
     } else if (0 === depth) {
      return this;
     }
     var clone = this.constructClone();
     return this.forEach(function(value, key) {
      clone.add(Object.clone(value, depth - 1, memo), key);
     }, this), clone;
    }, GenericCollection.prototype.only = function() {
     if (1 === this.length) {
      return this.one();
     }
    }, GenericCollection.prototype.iterator = function() {
     return this.iterate.apply(this, arguments);
    }, GenericCollection._sizePropertyDescriptor = {
     get: function() {
      return this.length;
     },
     enumerable: !1,
     configurable: !0
    }, Object.defineProperty(GenericCollection.prototype, "size", GenericCollection._sizePropertyDescriptor), 
    require("./shim-array");
   }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
  }, {
   "./shim-array": 24
  } ],
  10: [ function(require, module, exports) {
   "use strict";
   var Object = require("./shim-object"), Iterator = require("./iterator");
   function GenericMap() {
    throw new Error("Can't construct. GenericMap is a mixin.");
   }
   function Item(key, value) {
    this.key = key, this.value = value;
   }
   module.exports = GenericMap, GenericMap.prototype.isMap = !0, GenericMap.prototype.addEach = function(values) {
    var i;
    if (values && Object(values) === values) {
     if ("function" == typeof values.forEach) {
      !0 === values.isMap ? values.forEach(function(value, key) {
       this.set(key, value);
      }, this) : values.forEach(function(pair) {
       this.set(pair[0], pair[1]);
      }, this);
     } else if ("number" == typeof values.length) {
      for (i = 0; i < values.length; i++) {
       this.add(values[i], i);
      }
     } else {
      Object.keys(values).forEach(function(key) {
       this.set(key, values[key]);
      }, this);
     }
    } else if (values && "number" == typeof values.length) {
     for (i = 0; i < values.length; i++) {
      this.add(values[i], i);
     }
    }
    return this;
   }, GenericMap.prototype.get = function(key, defaultValue) {
    var item = this.store.get(new this.Item(key));
    return item ? item.value : arguments.length > 1 ? defaultValue : this.getDefault(key);
   }, GenericMap.prototype.set = function(key, value) {
    var item = new this.Item(key, value), found = this.store.get(item);
    return found ? (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, found.value), 
    found.value = value, this.dispatchesMapChanges && this.dispatchMapChange(key, value)) : (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, void 0), 
    this.store.add(item) && (this.length++, !0), this.dispatchesMapChanges && this.dispatchMapChange(key, value)), 
    this;
   }, GenericMap.prototype.add = function(value, key) {
    return this.set(key, value);
   }, GenericMap.prototype.has = function(key) {
    return this.store.has(new this.Item(key));
   }, GenericMap.prototype.delete = function(key) {
    var item = new this.Item(key);
    if (this.store.has(item)) {
     var from = this.store.get(item).value;
     return this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, from), this.store.delete(item), 
     this.length--, this.dispatchesMapChanges && this.dispatchMapChange(key, void 0), 
     !0;
    }
    return !1;
   }, GenericMap.prototype.clear = function() {
    var keys, key;
    if (this.dispatchesMapChanges && (this.forEach(function(value, key) {
     this.dispatchBeforeMapChange(key, value);
    }, this), keys = this.keysArray()), this.store.clear(), this.length = 0, this.dispatchesMapChanges) {
     for (var i = 0; key = keys[i]; i++) {
      this.dispatchMapChange(key);
     }
    }
   }, GenericMap.prototype.reduce = function(callback, basis, thisp) {
    return this.store.reduce(function(basis, item) {
     return callback.call(thisp, basis, item.value, item.key, this);
    }, basis, this);
   }, GenericMap.prototype.reduceRight = function(callback, basis, thisp) {
    return this.store.reduceRight(function(basis, item) {
     return callback.call(thisp, basis, item.value, item.key, this);
    }, basis, this);
   }, GenericMap.prototype.keysArray = function() {
    return this.map(function(value, key) {
     return key;
    });
   }, GenericMap.prototype.keys = function() {
    return new Iterator(this.keysArray());
   }, GenericMap.prototype.valuesArray = function() {
    return this.map(Function.identity);
   }, GenericMap.prototype.values = function() {
    return new Iterator(this.valuesArray());
   }, GenericMap.prototype.entriesArray = function() {
    return this.map(function(value, key) {
     return [ key, value ];
    });
   }, GenericMap.prototype.entries = function() {
    return new Iterator(this.entriesArray());
   }, GenericMap.prototype.items = function() {
    return this.entriesArray();
   }, GenericMap.prototype.equals = function(that, equals) {
    return equals = equals || Object.equals, this === that || (that && "function" == typeof that.every ? that.length === this.length && that.every(function(value, key) {
     return equals(this.get(key), value);
    }, this) : Object.keys(that).length === this.length && Object.keys(that).every(function(key) {
     return equals(this.get(key), that[key]);
    }, this));
   }, GenericMap.prototype.toJSON = function() {
    return this.entriesArray();
   }, GenericMap.prototype.Item = Item, Item.prototype.equals = function(that) {
    return Object.equals(this.key, that.key) && Object.equals(this.value, that.value);
   }, Item.prototype.compare = function(that) {
    return Object.compare(this.key, that.key);
   };
  }, {
   "./iterator": 13,
   "./shim-object": 26
  } ],
  11: [ function(require, module, exports) {
   var Object = require("./shim-object");
   function GenericOrder() {
    throw new Error("Can't construct. GenericOrder is a mixin.");
   }
   module.exports = GenericOrder, GenericOrder.prototype.equals = function(that, equals) {
    if (equals = equals || this.contentEquals || Object.equals, this === that) {
     return !0;
    }
    if (!that) {
     return !1;
    }
    return this.length === that.length && this.zip(that).every(function(pair) {
     return equals(pair[0], pair[1]);
    });
   }, GenericOrder.prototype.compare = function(that, compare) {
    if (compare = compare || this.contentCompare || Object.compare, this === that) {
     return 0;
    }
    if (!that) {
     return 1;
    }
    var length = Math.min(this.length, that.length), comparison = this.zip(that).reduce(function(comparison, pair, index) {
     return 0 === comparison ? index >= length ? comparison : compare(pair[0], pair[1]) : comparison;
    }, 0);
    return 0 === comparison ? this.length - that.length : comparison;
   }, GenericOrder.prototype.toJSON = function() {
    return this.toArray();
   };
  }, {
   "./shim-object": 26
  } ],
  12: [ function(require, module, exports) {
   function GenericSet() {
    throw new Error("Can't construct. GenericSet is a mixin.");
   }
   module.exports = GenericSet, GenericSet.prototype.isSet = !0, GenericSet.prototype.union = function(that) {
    var union = this.constructClone(this);
    return union.addEach(that), union;
   }, GenericSet.prototype.intersection = function(that) {
    return this.constructClone(this.filter(function(value) {
     return that.has(value);
    }));
   }, GenericSet.prototype.difference = function(that) {
    var union = this.constructClone(this);
    return union.deleteEach(that), union;
   }, GenericSet.prototype.symmetricDifference = function(that) {
    var union = this.union(that), intersection = this.intersection(that);
    return union.difference(intersection);
   }, GenericSet.prototype.deleteAll = function(value) {
    return +this.delete(value);
   }, GenericSet.prototype.equals = function(that, equals) {
    var self = this;
    return that && "function" == typeof that.reduce && this.length === that.length && that.reduce(function(equal, value) {
     return equal && self.has(value, equals);
    }, !0);
   }, GenericSet.prototype.forEach = function(callback) {
    var thisp = arguments[1];
    return this.reduce(function(undefined, value, key, object, depth) {
     callback.call(thisp, value, value, object, depth);
    }, void 0);
   }, GenericSet.prototype.toJSON = function() {
    return this.toArray();
   }, GenericSet.prototype.contains = function(value) {
    return this.has(value);
   }, GenericSet.prototype.remove = function(value) {
    return this.delete(value);
   }, GenericSet.prototype.toggle = function(value) {
    this.has(value) ? this.delete(value) : this.add(value);
   };
   var _valuesArrayFunction = function(value, key) {
    return value;
   };
   GenericSet.prototype.valuesArray = function() {
    return this.map(_valuesArrayFunction);
   };
   var _entriesArrayFunction = function(value, key) {
    return [ key, value ];
   };
   GenericSet.prototype.entriesArray = function() {
    return this.map(_entriesArrayFunction);
   };
  }, {} ],
  13: [ function(require, module, exports) {
   "use strict";
   module.exports = Iterator;
   var Object = require("./shim-object"), GenericCollection = require("./generic-collection");
   function Iterator(iterable) {
    var values = iterable && iterable.values && iterable.values();
    if (values && "function" == typeof values.next) {
     return values;
    }
    if (!(this instanceof Iterator)) {
     return new Iterator(iterable);
    }
    if (Array.isArray(iterable) || "string" == typeof iterable) {
     return Iterator.iterate(iterable);
    }
    if ((iterable = Object(iterable)) instanceof Iterator) {
     return iterable;
    }
    if (iterable.next) {
     this.next = function() {
      return iterable.next();
     };
    } else if (iterable.iterate) {
     var iterator = iterable.iterate();
     this.next = function() {
      return iterator.next();
     };
    } else {
     if ("[object Function]" !== Object.prototype.toString.call(iterable)) {
      throw new TypeError("Can't iterate " + iterable);
     }
     this.next = iterable;
    }
   }
   Iterator.prototype.forEach = GenericCollection.prototype.forEach, Iterator.prototype.map = GenericCollection.prototype.map, 
   Iterator.prototype.filter = GenericCollection.prototype.filter, Iterator.prototype.every = GenericCollection.prototype.every, 
   Iterator.prototype.some = GenericCollection.prototype.some, Iterator.prototype.any = GenericCollection.prototype.any, 
   Iterator.prototype.all = GenericCollection.prototype.all, Iterator.prototype.min = GenericCollection.prototype.min, 
   Iterator.prototype.max = GenericCollection.prototype.max, Iterator.prototype.sum = GenericCollection.prototype.sum, 
   Iterator.prototype.average = GenericCollection.prototype.average, Iterator.prototype.flatten = GenericCollection.prototype.flatten, 
   Iterator.prototype.zip = GenericCollection.prototype.zip, Iterator.prototype.enumerate = GenericCollection.prototype.enumerate, 
   Iterator.prototype.sorted = GenericCollection.prototype.sorted, Iterator.prototype.group = GenericCollection.prototype.group, 
   Iterator.prototype.reversed = GenericCollection.prototype.reversed, Iterator.prototype.toArray = GenericCollection.prototype.toArray, 
   Iterator.prototype.toObject = GenericCollection.prototype.toObject, Iterator.prototype.iterator = GenericCollection.prototype.iterator, 
   Iterator.prototype.__iterationObject = null, Object.defineProperty(Iterator.prototype, "_iterationObject", {
    get: function() {
     return this.__iterationObject || (this.__iterationObject = {
      done: !1,
      value: void 0
     });
    }
   }), Iterator.prototype.constructClone = function(values) {
    var clone = [];
    return clone.addEach(values), clone;
   }, Iterator.prototype.mapIterator = function(callback) {
    var self = Iterator(this), thisp = arguments[1], i = 0;
    if ("[object Function]" != Object.prototype.toString.call(callback)) {
     throw new TypeError();
    }
    return new self.constructor(function() {
     if (!0 !== self._iterationObject.done) {
      var callbackValue = callback.call(thisp, self.next().value, i++, self);
      self._iterationObject.value = callbackValue;
     }
     return self._iterationObject;
    });
   }, Iterator.prototype.filterIterator = function(callback) {
    var self = Iterator(this), thisp = arguments[1], i = 0;
    if ("[object Function]" != Object.prototype.toString.call(callback)) {
     throw new TypeError();
    }
    return new self.constructor(function() {
     for (var nextEntry; ;) {
      if (!0 === (nextEntry = self.next()).done) {
       return nextEntry;
      }
      if (callback.call(thisp, nextEntry.value, i++, self)) {
       return nextEntry;
      }
     }
    });
   }, Iterator.prototype.reduce = function(callback) {
    var nextEntry, self = Iterator(this), result = arguments[1], thisp = arguments[2], i = 0;
    if ("[object Function]" != Object.prototype.toString.call(callback)) {
     throw new TypeError();
    }
    if (!0 === (nextEntry = self.next()).done) {
     if (arguments.length > 1) {
      return arguments[1];
     }
     throw TypeError("cannot reduce a value from an empty iterator with no initial value");
    }
    for (result = arguments.length > 1 ? callback.call(thisp, result, nextEntry.value, i, self) : nextEntry.value, 
    i++; ;) {
     if (!0 === (nextEntry = self.next()).done) {
      return result;
     }
     result = callback.call(thisp, result, nextEntry.value, i, self), i++;
    }
   }, Iterator.prototype.concat = function() {
    return Iterator.concat(Array.prototype.concat.apply(this, arguments));
   }, Iterator.prototype.dropWhile = function(callback) {
    var stopValue, nextEntry, self = Iterator(this), thisp = arguments[1], stopped = !1, i = 0;
    if ("[object Function]" != Object.prototype.toString.call(callback)) {
     throw new TypeError();
    }
    for (;!0 !== (nextEntry = self.next()).done; ) {
     if (!callback.call(thisp, nextEntry.value, i, self)) {
      stopped = !0, stopValue = nextEntry.value;
      break;
     }
     i++;
    }
    return stopped ? self.constructor([ stopValue ]).concat(self) : self.constructor([]);
   }, Iterator.prototype.takeWhile = function(callback) {
    var self = Iterator(this), thisp = arguments[1], i = 0;
    if ("[object Function]" != Object.prototype.toString.call(callback)) {
     throw new TypeError();
    }
    return new self.constructor(function() {
     if (!0 !== self._iterationObject.done) {
      var value = self.next().value;
      callback.call(thisp, value, i++, self) ? self._iterationObject.value = value : (self._iterationObject.done = !0, 
      self._iterationObject.value = void 0);
     }
     return self._iterationObject;
    });
   }, Iterator.prototype.zipIterator = function() {
    return Iterator.unzip(Array.prototype.concat.apply(this, arguments));
   }, Iterator.prototype.enumerateIterator = function(start) {
    return Iterator.count(start).zipIterator(this);
   }, Iterator.iterate = function(iterable) {
    var start;
    return start = 0, new Iterator(function() {
     if ("object" == typeof iterable) {
      for (;!(start in iterable); ) {
       if (start >= iterable.length) {
        this._iterationObject.done = !0, this._iterationObject.value = void 0;
        break;
       }
       start += 1;
      }
     } else {
      start >= iterable.length && (this._iterationObject.done = !0, this._iterationObject.value = void 0);
     }
     return this._iterationObject.done || (this._iterationObject.value = iterable[start], 
     start += 1), this._iterationObject;
    });
   }, Iterator.cycle = function(cycle, times) {
    var next;
    return arguments.length < 2 && (times = 1 / 0), new Iterator(function() {
     var iteration, nextEntry;
     return next && (nextEntry = next()), next && !0 !== nextEntry.done || (times > 0 ? (times--, 
     iteration = Iterator.iterate(cycle), nextEntry = (next = iteration.next.bind(iteration))()) : (this._iterationObject.done = !0, 
     nextEntry = this._iterationObject)), nextEntry;
    });
   }, Iterator.concat = function(iterators) {
    var next;
    return iterators = Iterator(iterators), new Iterator(function() {
     var iteration, nextEntry;
     return next && (nextEntry = next()), nextEntry && !0 !== nextEntry.done ? nextEntry : !1 === (nextEntry = iterators.next()).done ? (iteration = Iterator(nextEntry.value), 
     (next = iteration.next.bind(iteration))()) : nextEntry;
    });
   }, Iterator.unzip = function(iterators) {
    return 0 === (iterators = Iterator(iterators).map(Iterator)).length ? new Iterator([]) : new Iterator(function() {
     var stopped, nextEntry, result = iterators.map(function(iterator) {
      return !0 === (nextEntry = iterator.next()).done && (stopped = !0), nextEntry.value;
     });
     return stopped ? (this._iterationObject.done = !0, this._iterationObject.value = void 0) : this._iterationObject.value = result, 
     this._iterationObject;
    });
   }, Iterator.zip = function() {
    return Iterator.unzip(Array.prototype.slice.call(arguments));
   }, Iterator.chain = function() {
    return Iterator.concat(Array.prototype.slice.call(arguments));
   }, Iterator.range = function(start, stop, step) {
    return arguments.length < 3 && (step = 1), arguments.length < 2 && (stop = start, 
    start = 0), start = start || 0, step = step || 1, new Iterator(function() {
     start >= stop && (this._iterationObject.done = !0, this._iterationObject.value = void 0);
     var result = start;
     return start += step, this._iterationObject.value = result, this._iterationObject;
    });
   }, Iterator.count = function(start, step) {
    return Iterator.range(start, 1 / 0, step);
   }, Iterator.repeat = function(value, times) {
    return new Iterator.range(times).mapIterator(function() {
     return value;
    });
   };
  }, {
   "./generic-collection": 9,
   "./shim-object": 26
  } ],
  14: [ function(require, module, exports) {
   "use strict";
   var _List = require("./_list"), PropertyChanges = require("./listen/property-changes"), RangeChanges = require("./listen/range-changes");
   function List(values, equals, getDefault) {
    return _List._init(List, this, values, equals, getDefault);
   }
   module.exports = List, List.prototype = new _List(), List.prototype.constructor = List, 
   List.List = List, List.from = _List.from, Object.addEach(List.prototype, PropertyChanges.prototype), 
   Object.addEach(List.prototype, RangeChanges.prototype), List.prototype.makeObservable = function() {
    this.head.index = -1, this.updateIndexes(this.head.next, 0), this.dispatchesRangeChanges = !0;
   }, Object.defineProperties(List.prototype, {
    _dispatchEmptyArray: {
     value: []
    }
   }), List.prototype.delete = function(value, equals) {
    var found = this.findLast(value, equals);
    if (found) {
     if (this.dispatchesRangeChanges) {
      var plus = [], minus = [ value ];
      this.dispatchBeforeRangeChange(plus, minus, found.index);
     }
     return found.delete(), this.length--, this.dispatchesRangeChanges && (this.updateIndexes(found.next, found.index), 
     this.dispatchRangeChange(plus, minus, found.index)), !0;
    }
    return !1;
   }, Object.defineProperty(List.prototype, "superClear", {
    value: _List.prototype.clear,
    enumerable: !1,
    configurable: !0,
    writable: !0
   }), List.prototype.clear = function() {
    var plus, minus;
    this.dispatchesRangeChanges && (minus = this.toArray(), plus = [], this.dispatchBeforeRangeChange(plus, minus, 0)), 
    this.superClear(), this.dispatchesRangeChanges && this.dispatchRangeChange(plus, minus, 0);
   }, List.prototype.add = function(value) {
    var node = new this.Node(value);
    return this.dispatchesRangeChanges && (node.index = this.length, this.dispatchBeforeRangeChange([ value ], [], node.index)), 
    this._addNode(node), this.dispatchesRangeChanges && this.dispatchRangeChange([ value ], [], node.index), 
    !0;
   }, Object.defineProperty(List.prototype, "superPush", {
    value: _List.prototype.push,
    enumerable: !1,
    configurable: !0,
    writable: !0
   }), List.prototype.push = function() {
    if (this.dispatchesRangeChanges) {
     var plus = Array.prototype.slice.call(arguments), minus = [], index = this.length;
     this.dispatchBeforeRangeChange(plus, minus, index);
     var start = this.head.prev;
    }
    1 === arguments.length ? this.superPush.call(this, arguments[0]) : 2 === arguments.length ? this.superPush.call(this, arguments[0], arguments[1]) : this.superPush.apply(this, arguments), 
    this.dispatchesRangeChanges && (this.updateIndexes(start.next, void 0 === start.index ? 0 : start.index + 1), 
    this.dispatchRangeChange(plus, minus, index));
   }, Object.defineProperty(List.prototype, "superUnshift", {
    value: _List.prototype.unshift,
    enumerable: !1,
    configurable: !0,
    writable: !0
   }), List.prototype.unshift = function() {
    if (this.dispatchesRangeChanges) {
     var plus = Array.prototype.slice.call(arguments), minus = [];
     this.dispatchBeforeRangeChange(plus, minus, 0);
    }
    1 === arguments.length ? this.superUnshift.call(this, arguments[0]) : 2 === arguments.length ? this.superUnshift.call(this, arguments[0], arguments[1]) : this.superUnshift.apply(this, arguments), 
    this.dispatchesRangeChanges && (this.updateIndexes(this.head.next, 0), this.dispatchRangeChange(plus, minus, 0));
   }, Object.defineProperty(List.prototype, "_beforePop", {
    value: function(value, index) {
     var popDispatchValueArray;
     return this.dispatchesRangeChanges && (popDispatchValueArray = [ value ], this.dispatchBeforeRangeChange(this._dispatchEmptyArray, popDispatchValueArray, index)), 
     popDispatchValueArray;
    },
    enumerable: !1,
    configurable: !0,
    writable: !0
   }), Object.defineProperty(List.prototype, "_afterPop", {
    value: function(value, index, popDispatchValueArray) {
     this.dispatchesRangeChanges && this.dispatchRangeChange(this._dispatchEmptyArray, popDispatchValueArray, index);
    },
    enumerable: !1,
    configurable: !0,
    writable: !0
   }), Object.defineProperty(List.prototype, "superPop", {
    value: _List.prototype.pop,
    enumerable: !1,
    configurable: !0,
    writable: !0
   }), List.prototype.pop = function() {
    return this.superPop(this._beforePop, this._afterPop);
   }, Object.defineProperty(List.prototype, "_beforeShift", {
    value: function(value, index) {
     var dispatchValueArray;
     return this.dispatchesRangeChanges && (dispatchValueArray = [ value ], this.dispatchBeforeRangeChange(this._dispatchEmptyArray, dispatchValueArray, index)), 
     dispatchValueArray;
    },
    enumerable: !1,
    configurable: !0,
    writable: !0
   }), Object.defineProperty(List.prototype, "_afterShift", {
    value: function(value, index, dispatchValueArray) {
     this.dispatchesRangeChanges && (this.updateIndexes(this.head.next, index), this.dispatchRangeChange(this._dispatchEmptyArray, dispatchValueArray, index));
    },
    enumerable: !1,
    configurable: !0,
    writable: !0
   }), Object.defineProperty(List.prototype, "superShift", {
    value: _List.prototype.shift,
    enumerable: !1,
    configurable: !0,
    writable: !0
   }), List.prototype.shift = function() {
    return this.superShift(this._beforeShift, this._afterShift);
   }, Object.defineProperty(List.prototype, "superSwap", {
    value: _List.prototype.swap,
    enumerable: !1,
    configurable: !0,
    writable: !0
   }), List.prototype.swap = function(start, length, plus) {
    var index, startNode;
    return this.superSwap(start, length, plus, function(start, plus, minus) {
     this.dispatchesRangeChanges && (index = start === this.head ? this.length : start.prev === this.head ? 0 : start.index, 
     startNode = start.prev, this.dispatchBeforeRangeChange(plus, minus, index));
    }, function(start, plus, minus) {
     this.dispatchesRangeChanges && (start === this.head ? this.updateIndexes(this.head.next, 0) : this.updateIndexes(startNode.next, startNode.index + 1), 
     this.dispatchRangeChange(plus, minus, index));
    });
   }, Object.defineProperty(List.prototype, "superReverse", {
    value: _List.prototype.reverse,
    enumerable: !1,
    configurable: !0,
    writable: !0
   }), List.prototype.reverse = function() {
    if (this.dispatchesRangeChanges) {
     var minus = this.toArray(), plus = minus.reversed();
     this.dispatchBeforeRangeChange(plus, minus, 0);
    }
    return this.superReverse(), this.dispatchesRangeChanges && this.dispatchRangeChange(plus, minus, 0), 
    this;
   };
  }, {
   "./_list": 3,
   "./listen/property-changes": 17,
   "./listen/range-changes": 18
  } ],
  15: [ function(require, module, exports) {
   var Map = require("../_map"), ObjectChangeDescriptor = module.exports.ObjectChangeDescriptor = function ObjectChangeDescriptor(name) {
    return this.name = name, this.isActive = !1, this._willChangeListeners = null, this._changeListeners = null, 
    this;
   };
   Object.defineProperties(ObjectChangeDescriptor.prototype, {
    name: {
     value: null,
     writable: !0
    },
    isActive: {
     value: !1,
     writable: !0
    },
    _willChangeListeners: {
     value: null,
     writable: !0
    },
    willChangeListeners: {
     get: function() {
      return this._willChangeListeners || (this._willChangeListeners = new this.willChangeListenersRecordConstructor(this.name));
     }
    },
    _changeListeners: {
     value: null,
     writable: !0
    },
    changeListeners: {
     get: function() {
      return this._changeListeners || (this._changeListeners = new this.changeListenersRecordConstructor(this.name));
     }
    },
    changeListenersRecordConstructor: {
     value: ChangeListenersRecord,
     writable: !0
    },
    willChangeListenersRecordConstructor: {
     value: ChangeListenersRecord,
     writable: !0
    }
   });
   var ListenerGhost = module.exports.ListenerGhost = Object.create(null), ChangeListenerSpecificHandlerMethodName = new Map();
   function ChangeListenersRecord(name) {
    var specificHandlerMethodName = ChangeListenerSpecificHandlerMethodName.get(name);
    return specificHandlerMethodName || (specificHandlerMethodName = "handle", specificHandlerMethodName += name, 
    specificHandlerMethodName += "Change", ChangeListenerSpecificHandlerMethodName.set(name, specificHandlerMethodName)), 
    this._current = null, this._current = null, this.specificHandlerMethodName = specificHandlerMethodName, 
    this;
   }
   module.exports.ChangeListenersRecord = ChangeListenersRecord, Object.defineProperties(ChangeListenersRecord.prototype, {
    _current: {
     value: null,
     writable: !0
    },
    current: {
     get: function() {
      return this._current;
     },
     set: function(value) {
      this._current = value;
     }
    },
    ListenerGhost: {
     value: ListenerGhost,
     writable: !0
    },
    ghostCount: {
     value: 0,
     writable: !0
    },
    maxListenerGhostRatio: {
     value: .3,
     writable: !0
    },
    listenerGhostFilter: {
     value: function listenerGhostFilter(value) {
      return value !== this.ListenerGhost;
     }
    },
    removeCurrentGostListenersIfNeeded: {
     value: function() {
      return this._current && this.ghostCount / this._current.length > this.maxListenerGhostRatio && (this.ghostCount = 0, 
      this._current = this._current.filter(this.listenerGhostFilter, this)), this._current;
     }
    },
    dispatchBeforeChange: {
     value: !1,
     writable: !0
    },
    genericHandlerMethodName: {
     value: "handlePropertyChange",
     writable: !0
    }
   }), module.exports.WillChangeListenersRecord = WillChangeListenersRecord;
   var WillChangeListenerSpecificHandlerMethodName = new Map();
   function WillChangeListenersRecord(name) {
    var specificHandlerMethodName = WillChangeListenerSpecificHandlerMethodName.get(name);
    return specificHandlerMethodName || (specificHandlerMethodName = "handle", specificHandlerMethodName += name, 
    specificHandlerMethodName += "WillChange", WillChangeListenerSpecificHandlerMethodName.set(name, specificHandlerMethodName)), 
    this.specificHandlerMethodName = specificHandlerMethodName, this;
   }
   WillChangeListenersRecord.prototype = new ChangeListenersRecord(), WillChangeListenersRecord.prototype.constructor = WillChangeListenersRecord, 
   WillChangeListenersRecord.prototype.genericHandlerMethodName = "handlePropertyWillChange";
  }, {
   "../_map": 4
  } ],
  16: [ function(require, module, exports) {
   "use strict";
   var WeakMap = require("../weak-map"), Map = require("../_map"), ChangeDescriptor = require("./change-descriptor"), ObjectChangeDescriptor = ChangeDescriptor.ObjectChangeDescriptor, ChangeListenersRecord = ChangeDescriptor.ChangeListenersRecord, ListenerGhost = ChangeDescriptor.ListenerGhost;
   function MapChanges() {
    throw new Error("Can't construct. MapChanges is a mixin.");
   }
   module.exports = MapChanges;
   Object.prototype.hasOwnProperty;
   var mapChangeDescriptors = new WeakMap();
   function MapChangeDescriptor(name) {
    this.name = name, this.isActive = !1, this._willChangeListeners = null, this._changeListeners = null;
   }
   MapChangeDescriptor.prototype = new ObjectChangeDescriptor(), MapChangeDescriptor.prototype.constructor = MapChangeDescriptor, 
   MapChangeDescriptor.prototype.changeListenersRecordConstructor = MapChangeListenersRecord, 
   MapChangeDescriptor.prototype.willChangeListenersRecordConstructor = MapWillChangeListenersRecord;
   var MapChangeListenersSpecificHandlerMethodName = new Map();
   function MapChangeListenersRecord(name) {
    var specificHandlerMethodName = MapChangeListenersSpecificHandlerMethodName.get(name);
    return specificHandlerMethodName || (specificHandlerMethodName = "handle", specificHandlerMethodName += name.slice(0, 1).toUpperCase(), 
    specificHandlerMethodName += name.slice(1), specificHandlerMethodName += "MapChange", 
    MapChangeListenersSpecificHandlerMethodName.set(name, specificHandlerMethodName)), 
    this.specificHandlerMethodName = specificHandlerMethodName, this;
   }
   MapChangeListenersRecord.prototype = new ChangeListenersRecord(), MapChangeListenersRecord.prototype.constructor = MapChangeListenersRecord, 
   MapChangeListenersRecord.prototype.genericHandlerMethodName = "handleMapChange";
   var MapWillChangeListenersSpecificHandlerMethodName = new Map();
   function MapWillChangeListenersRecord(name) {
    var specificHandlerMethodName = MapWillChangeListenersSpecificHandlerMethodName.get(name);
    return specificHandlerMethodName || (specificHandlerMethodName = "handle", specificHandlerMethodName += name.slice(0, 1).toUpperCase(), 
    specificHandlerMethodName += name.slice(1), specificHandlerMethodName += "MapWillChange", 
    MapWillChangeListenersSpecificHandlerMethodName.set(name, specificHandlerMethodName)), 
    this.specificHandlerMethodName = specificHandlerMethodName, this;
   }
   MapWillChangeListenersRecord.prototype = new ChangeListenersRecord(), MapWillChangeListenersRecord.prototype.constructor = MapWillChangeListenersRecord, 
   MapWillChangeListenersRecord.prototype.genericHandlerMethodName = "handleMapWillChange", 
   MapChanges.prototype.getAllMapChangeDescriptors = function() {
    return mapChangeDescriptors.has(this) || mapChangeDescriptors.set(this, new Map()), 
    mapChangeDescriptors.get(this);
   }, MapChanges.prototype.getMapChangeDescriptor = function(token) {
    var tokenChangeDescriptors = this.getAllMapChangeDescriptors();
    return token = token || "", tokenChangeDescriptors.has(token) || tokenChangeDescriptors.set(token, new MapChangeDescriptor(token)), 
    tokenChangeDescriptors.get(token);
   };
   var ObjectsDispatchesMapChanges = new WeakMap(), dispatchesChangesPropertyDescriptor = {
    get: function() {
     return ObjectsDispatchesMapChanges.get(this);
    },
    set: function(value) {
     return ObjectsDispatchesMapChanges.set(this, value);
    },
    configurable: !0,
    enumerable: !1
   };
   MapChanges.prototype.addMapChangeListener = function addMapChangeListener(listener, token, beforeChange) {
    !this.isObservable && this.makeObservable && this.makeObservable();
    var listeners, descriptor = this.getMapChangeDescriptor(token);
    (listeners = beforeChange ? descriptor.willChangeListeners : descriptor.changeListeners)._current ? Array.isArray(listeners._current) ? listeners._current.push(listener) : listeners._current = [ listeners._current, listener ] : listeners._current = listener, 
    void 0 === Object.getOwnPropertyDescriptor(this.__proto__ || Object.getPrototypeOf(this), "dispatchesMapChanges") && Object.defineProperty(this.__proto__ || Object.getPrototypeOf(this), "dispatchesMapChanges", dispatchesChangesPropertyDescriptor), 
    this.dispatchesMapChanges = !0;
    var self = this;
    return function cancelMapChangeListener() {
     self && (self.removeMapChangeListener(listener, token, beforeChange), self = null);
    };
   }, MapChanges.prototype.removeMapChangeListener = function(listener, token, beforeChange) {
    var listeners, descriptor = this.getMapChangeDescriptor(token);
    if ((listeners = beforeChange ? descriptor.willChangeListeners : descriptor.changeListeners)._current) {
     if (listeners._current === listener) {
      listeners._current = null;
     } else {
      var index = listeners._current.lastIndexOf(listener);
      if (-1 === index) {
       throw new Error("Can't remove map change listener: does not exist: token " + JSON.stringify(token));
      }
      descriptor.isActive ? (listeners.ghostCount = listeners.ghostCount + 1, listeners._current[index] = ListenerGhost) : listeners._current.spliceOne(index);
     }
    }
   }, MapChanges.prototype.dispatchMapChange = function(key, value, beforeChange) {
    var descriptors = this.getAllMapChangeDescriptors(), Ghost = ListenerGhost;
    descriptors.forEach(function(descriptor, token) {
     if (!descriptor.isActive) {
      var listeners = beforeChange ? descriptor.willChangeListeners : descriptor.changeListeners;
      if (listeners && listeners._current) {
       var tokenName = listeners.specificHandlerMethodName;
       if (Array.isArray(listeners._current)) {
        if (listeners._current.length) {
         var i, countI, listener, currentListeners = listeners.removeCurrentGostListenersIfNeeded();
         descriptor.isActive = !0;
         try {
          for (i = 0, countI = currentListeners.length; i < countI; i++) {
           if ((listener = currentListeners[i]) !== Ghost) {
            if (listener[tokenName]) {
             listener[tokenName](value, key, this);
            } else {
             if (!listener.call) {
              throw new Error("Handler " + listener + " has no method " + tokenName + " and is not callable");
             }
             listener.call(listener, value, key, this);
            }
           }
          }
         } finally {
          descriptor.isActive = !1;
         }
        }
       } else {
        descriptor.isActive = !0;
        try {
         if ((listener = listeners._current)[tokenName]) {
          listener[tokenName](value, key, this);
         } else {
          if (!listener.call) {
           throw new Error("Handler " + listener + " has no method " + tokenName + " and is not callable");
          }
          listener.call(listener, value, key, this);
         }
        } finally {
         descriptor.isActive = !1;
        }
       }
      }
     }
    }, this);
   }, MapChanges.prototype.addBeforeMapChangeListener = function(listener, token) {
    return this.addMapChangeListener(listener, token, !0);
   }, MapChanges.prototype.removeBeforeMapChangeListener = function(listener, token) {
    return this.removeMapChangeListener(listener, token, !0);
   }, MapChanges.prototype.dispatchBeforeMapChange = function(key, value) {
    return this.dispatchMapChange(key, value, !0);
   };
  }, {
   "../_map": 4,
   "../weak-map": 35,
   "./change-descriptor": 15
  } ],
  17: [ function(require, module, exports) {
   Object.prototype.hasOwnProperty;
   function PropertyChanges() {
    throw new Error("This is an abstract interface. Mix it. Don't construct it");
   }
   module.exports = PropertyChanges, require("../shim");
   var Map = require("../_map"), WeakMap = require("../weak-map"), ChangeDescriptor = require("./change-descriptor"), ObjectChangeDescriptor = ChangeDescriptor.ObjectChangeDescriptor, ListenerGhost = ChangeDescriptor.ListenerGhost;
   PropertyChanges.debug = !0;
   var ObjectsPropertyChangeListeners = new WeakMap(), ObjectChangeDescriptorName = new Map();
   function dispatchEach(listeners, key, value, object) {
    if (listeners && listeners._current) {
     var current, listener, i, countI, thisp, specificHandlerMethodName = listeners.specificHandlerMethodName, genericHandlerMethodName = listeners.genericHandlerMethodName, Ghost = ListenerGhost;
     if (Array.isArray(listeners._current)) {
      for (i = 0, countI = (current = listeners.removeCurrentGostListenersIfNeeded()).length; i < countI; i++) {
       if ((thisp = current[i]) !== Ghost) {
        if (!(listener = thisp[specificHandlerMethodName] || thisp[genericHandlerMethodName] || thisp).call) {
         throw new Error("No event listener for " + listeners.specificHandlerName + " or " + listeners.genericHandlerName + " or call on " + listener);
        }
        listener.call(thisp, value, key, object);
       }
      }
     } else {
      if (!(listener = (thisp = listeners._current)[specificHandlerMethodName] || thisp[genericHandlerMethodName] || thisp).call) {
       throw new Error("No event listener for " + listeners.specificHandlerName + " or " + listeners.genericHandlerName + " or call on " + listener);
      }
      listener.call(thisp, value, key, object);
     }
    }
   }
   PropertyChanges.ObjectChangeDescriptor = function() {}, PropertyChanges.prototype.getOwnPropertyChangeDescriptor = function(key) {
    var keyChangeDescriptor, objectPropertyChangeDescriptors = ObjectsPropertyChangeListeners.get(this);
    if (objectPropertyChangeDescriptors || (objectPropertyChangeDescriptors = Object.create(null), 
    ObjectsPropertyChangeListeners.set(this, objectPropertyChangeDescriptors)), void 0 === (keyChangeDescriptor = objectPropertyChangeDescriptors[key])) {
     var propertyName = ObjectChangeDescriptorName.get(key);
     return propertyName || (propertyName = (propertyName = String(key)) && propertyName[0].toUpperCase() + propertyName.slice(1), 
     ObjectChangeDescriptorName.set(key, propertyName)), objectPropertyChangeDescriptors[key] = new ObjectChangeDescriptor(propertyName);
    }
    return keyChangeDescriptor;
   }, PropertyChanges.prototype.hasOwnPropertyChangeDescriptor = function(key) {
    var objectPropertyChangeDescriptors = ObjectsPropertyChangeListeners.get(this);
    return !!objectPropertyChangeDescriptors && (!key || void 0 !== objectPropertyChangeDescriptors[key]);
   }, PropertyChanges.prototype.addOwnPropertyChangeListener = function(key, listener, beforeChange) {
    this.makeObservable && !this.isObservable && this.makeObservable();
    var descriptor = PropertyChanges.getOwnPropertyChangeDescriptor(this, key), listeners = beforeChange ? descriptor.willChangeListeners : descriptor.changeListeners;
    PropertyChanges.makePropertyObservable(this, key), listeners._current ? Array.isArray(listeners._current) ? listeners._current.push(listener) : listeners._current = [ listeners._current, listener ] : listeners._current = listener;
    var self = this;
    return function cancelOwnPropertyChangeListener() {
     PropertyChanges.removeOwnPropertyChangeListener(self, key, listener, beforeChange), 
     self = null;
    };
   }, PropertyChanges.prototype.addBeforeOwnPropertyChangeListener = function(key, listener) {
    return PropertyChanges.addOwnPropertyChangeListener(this, key, listener, !0);
   }, PropertyChanges.prototype.removeOwnPropertyChangeListener = function removeOwnPropertyChangeListener(key, listener, beforeChange) {
    var listeners, descriptor = PropertyChanges.getOwnPropertyChangeDescriptor(this, key);
    if ((listeners = beforeChange ? descriptor._willChangeListeners : descriptor._changeListeners) && listeners._current) {
     if (listeners._current === listener) {
      listeners._current = null;
     } else {
      var index = listeners._current.lastIndexOf(listener);
      if (-1 === index) {
       throw new Error("Can't remove property change listener: does not exist: property name" + JSON.stringify(key));
      }
      descriptor.isActive ? (listeners.ghostCount = listeners.ghostCount + 1, listeners._current[index] = removeOwnPropertyChangeListener.ListenerGhost) : listeners._current.spliceOne(index);
     }
    }
   }, PropertyChanges.prototype.removeOwnPropertyChangeListener.ListenerGhost = ListenerGhost, 
   PropertyChanges.prototype.removeBeforeOwnPropertyChangeListener = function(key, listener) {
    return PropertyChanges.removeOwnPropertyChangeListener(this, key, listener, !0);
   }, PropertyChanges.prototype.dispatchOwnPropertyChange = function dispatchOwnPropertyChange(key, value, beforeChange) {
    var listeners, descriptor = PropertyChanges.getOwnPropertyChangeDescriptor(this, key);
    if (!descriptor.isActive) {
     descriptor.isActive = !0, listeners = beforeChange ? descriptor._willChangeListeners : descriptor._changeListeners;
     try {
      dispatchOwnPropertyChange.dispatchEach(listeners, key, value, this);
     } finally {
      descriptor.isActive = !1;
     }
    }
   }, PropertyChanges.prototype.dispatchOwnPropertyChange.dispatchEach = dispatchEach, 
   dispatchEach.ListenerGhost = ListenerGhost, PropertyChanges.prototype.dispatchBeforeOwnPropertyChange = function(key, listener) {
    return PropertyChanges.dispatchOwnPropertyChange(this, key, listener, !0);
   };
   var ObjectsOverriddenPropertyDescriptors = new WeakMap(), propertyListener = (new WeakMap(), 
   {
    get: void 0,
    set: void 0,
    configurable: !0,
    enumerable: !1
   });
   PropertyChanges.prototype.makePropertyObservable = function(key) {
    var overriddenPropertyDescriptors = ObjectsOverriddenPropertyDescriptors.get(this);
    if (!overriddenPropertyDescriptors || void 0 === overriddenPropertyDescriptors.get(key)) {
     if (!overriddenPropertyDescriptors) {
      if (Array.isArray(this)) {
       return;
      }
      if (!Object.isExtensible(this)) {
       throw new Error("Can't make property " + JSON.stringify(key) + " observable on " + this + " because object is not extensible");
      }
      overriddenPropertyDescriptors = new Map(), ObjectsOverriddenPropertyDescriptors.set(this, overriddenPropertyDescriptors);
     }
     var overriddenDescriptor, attached = this;
     do {
      if (overriddenDescriptor = Object.getOwnPropertyDescriptor(attached, key)) {
       break;
      }
      attached = Object.getPrototypeOf(attached);
     } while (attached);
     if (overriddenDescriptor) {
      if (!overriddenDescriptor.configurable) {
       return;
      }
      if (!overriddenDescriptor.writable && !overriddenDescriptor.set) {
       return;
      }
     } else {
      overriddenDescriptor = {
       value: void 0,
       enumerable: !0,
       writable: !0,
       configurable: !0
      };
     }
     overriddenPropertyDescriptors.set(key, overriddenDescriptor), 'value' in overriddenDescriptor ? (propertyListener.get = function dispatchingGetter() {
      return dispatchingGetter.overriddenDescriptor.value;
     }, propertyListener.set = function dispatchingSetter(value) {
      var descriptor, isActive, overriddenDescriptor = dispatchingSetter.overriddenDescriptor;
      if (value !== overriddenDescriptor.value) {
       if (!(isActive = (descriptor = dispatchingSetter.descriptor).isActive)) {
        descriptor.isActive = !0;
        try {
         dispatchingSetter.dispatchEach(descriptor._willChangeListeners, dispatchingSetter.key, overriddenDescriptor.value, this);
        } finally {}
       }
       if (overriddenDescriptor.value = value, !isActive) {
        try {
         dispatchingSetter.dispatchEach(descriptor._changeListeners, dispatchingSetter.key, value, this);
        } finally {
         descriptor.isActive = !1;
        }
       }
      }
     }, propertyListener.set.dispatchEach = dispatchEach, propertyListener.set.key = key, 
     propertyListener.get.overriddenDescriptor = propertyListener.set.overriddenDescriptor = overriddenDescriptor, 
     propertyListener.set.descriptor = ObjectsPropertyChangeListeners.get(this)[key], 
     propertyListener.enumerable = overriddenDescriptor.enumerable, propertyListener.configurable = !0) : (propertyListener.get = overriddenDescriptor.get, 
     propertyListener.set = function dispatchingSetter() {
      var descriptor, isActive, newValue, formerValue = dispatchingSetter.overriddenGetter.call(this);
      if (1 === arguments.length ? dispatchingSetter.overriddenSetter.call(this, arguments[0]) : 2 === arguments.length ? dispatchingSetter.overriddenSetter.call(this, arguments[0], arguments[1]) : dispatchingSetter.overriddenSetter.apply(this, arguments), 
      (newValue = dispatchingSetter.overriddenGetter.call(this)) !== formerValue) {
       if (!(isActive = (descriptor = dispatchingSetter.descriptor).isActive)) {
        descriptor.isActive = !0;
        try {
         dispatchingSetter.dispatchEach(descriptor._willChangeListeners, key, formerValue, this);
        } finally {}
       }
       if (!isActive) {
        try {
         dispatchingSetter.dispatchEach(descriptor._changeListeners, key, newValue, this);
        } finally {
         descriptor.isActive = !1;
        }
       }
      }
     }, propertyListener.enumerable = overriddenDescriptor.enumerable, propertyListener.configurable = !0, 
     propertyListener.set.dispatchEach = dispatchEach, propertyListener.set.overriddenSetter = overriddenDescriptor.set, 
     propertyListener.set.overriddenGetter = overriddenDescriptor.get, propertyListener.set.descriptor = ObjectsPropertyChangeListeners.get(this)[key]), 
     Object.defineProperty(this, key, propertyListener);
    }
   }, PropertyChanges.getOwnPropertyChangeDescriptor = function(object, key) {
    return object.getOwnPropertyChangeDescriptor ? object.getOwnPropertyChangeDescriptor(key) : PropertyChanges.prototype.getOwnPropertyChangeDescriptor.call(object, key);
   }, PropertyChanges.hasOwnPropertyChangeDescriptor = function(object, key) {
    return object.hasOwnPropertyChangeDescriptor ? object.hasOwnPropertyChangeDescriptor(key) : PropertyChanges.prototype.hasOwnPropertyChangeDescriptor.call(object, key);
   }, PropertyChanges.addOwnPropertyChangeListener = function(object, key, listener, beforeChange) {
    if (Object.isObject(object)) {
     return object.addOwnPropertyChangeListener ? object.addOwnPropertyChangeListener(key, listener, beforeChange) : this.prototype.addOwnPropertyChangeListener.call(object, key, listener, beforeChange);
    }
   }, PropertyChanges.removeOwnPropertyChangeListener = function(object, key, listener, beforeChange) {
    if (Object.isObject(object)) {
     return object.removeOwnPropertyChangeListener ? object.removeOwnPropertyChangeListener(key, listener, beforeChange) : PropertyChanges.prototype.removeOwnPropertyChangeListener.call(object, key, listener, beforeChange);
    }
   }, PropertyChanges.dispatchOwnPropertyChange = function(object, key, value, beforeChange) {
    if (Object.isObject(object)) {
     return object.dispatchOwnPropertyChange ? object.dispatchOwnPropertyChange(key, value, beforeChange) : PropertyChanges.prototype.dispatchOwnPropertyChange.call(object, key, value, beforeChange);
    }
   }, PropertyChanges.addBeforeOwnPropertyChangeListener = function(object, key, listener) {
    return PropertyChanges.addOwnPropertyChangeListener(object, key, listener, !0);
   }, PropertyChanges.removeBeforeOwnPropertyChangeListener = function(object, key, listener) {
    return PropertyChanges.removeOwnPropertyChangeListener(object, key, listener, !0);
   }, PropertyChanges.dispatchBeforeOwnPropertyChange = function(object, key, value) {
    return PropertyChanges.dispatchOwnPropertyChange(object, key, value, !0);
   }, PropertyChanges.makePropertyObservable = function(object, key) {
    return object.makePropertyObservable ? object.makePropertyObservable(key) : PropertyChanges.prototype.makePropertyObservable.call(object, key);
   };
  }, {
   "../_map": 4,
   "../shim": 28,
   "../weak-map": 35,
   "./change-descriptor": 15
  } ],
  18: [ function(require, module, exports) {
   "use strict";
   var WeakMap = require("../weak-map"), Map = require("../_map"), ChangeDescriptor = require("./change-descriptor"), ObjectChangeDescriptor = ChangeDescriptor.ObjectChangeDescriptor, ChangeListenersRecord = ChangeDescriptor.ChangeListenersRecord, ListenerGhost = ChangeDescriptor.ListenerGhost, rangeChangeDescriptors = new WeakMap();
   function RangeChangeDescriptor(name) {
    this.name = name, this.isActive = !1, this._willChangeListeners = null, this._changeListeners = null;
   }
   RangeChangeDescriptor.prototype = new ObjectChangeDescriptor(), RangeChangeDescriptor.prototype.constructor = RangeChangeDescriptor, 
   RangeChangeDescriptor.prototype.changeListenersRecordConstructor = RangeChangeListenersRecord, 
   RangeChangeDescriptor.prototype.willChangeListenersRecordConstructor = RangeWillChangeListenersRecord, 
   Object.defineProperty(RangeChangeDescriptor.prototype, "active", {
    get: function() {
     return this._active || (this._active = this._current ? this._current.slice() : []);
    }
   });
   var RangeChangeListenersSpecificHandlerMethodName = new Map();
   function RangeChangeListenersRecord(name) {
    var specificHandlerMethodName = RangeChangeListenersSpecificHandlerMethodName.get(name);
    return specificHandlerMethodName || (specificHandlerMethodName = "handle", specificHandlerMethodName += name.slice(0, 1).toUpperCase(), 
    specificHandlerMethodName += name.slice(1), specificHandlerMethodName += "RangeChange", 
    RangeChangeListenersSpecificHandlerMethodName.set(name, specificHandlerMethodName)), 
    this.specificHandlerMethodName = specificHandlerMethodName, this;
   }
   RangeChangeListenersRecord.prototype = new ChangeListenersRecord(), RangeChangeListenersRecord.prototype.constructor = RangeChangeListenersRecord;
   var RangeWillChangeListenersSpecificHandlerMethodName = new Map();
   function RangeWillChangeListenersRecord(name) {
    var specificHandlerMethodName = RangeWillChangeListenersSpecificHandlerMethodName.get(name);
    return specificHandlerMethodName || (specificHandlerMethodName = "handle", specificHandlerMethodName += name.slice(0, 1).toUpperCase(), 
    specificHandlerMethodName += name.slice(1), specificHandlerMethodName += "RangeWillChange", 
    RangeWillChangeListenersSpecificHandlerMethodName.set(name, specificHandlerMethodName)), 
    this.specificHandlerMethodName = specificHandlerMethodName, this;
   }
   function RangeChanges() {
    throw new Error("Can't construct. RangeChanges is a mixin.");
   }
   RangeWillChangeListenersRecord.prototype = new ChangeListenersRecord(), RangeWillChangeListenersRecord.prototype.constructor = RangeWillChangeListenersRecord, 
   module.exports = RangeChanges, RangeChanges.prototype.getAllRangeChangeDescriptors = function() {
    return rangeChangeDescriptors.has(this) || rangeChangeDescriptors.set(this, new Map()), 
    rangeChangeDescriptors.get(this);
   }, RangeChanges.prototype.getRangeChangeDescriptor = function(token) {
    var tokenChangeDescriptors = this.getAllRangeChangeDescriptors();
    return token = token || "", tokenChangeDescriptors.has(token) || tokenChangeDescriptors.set(token, new RangeChangeDescriptor(token)), 
    tokenChangeDescriptors.get(token);
   };
   var ObjectsDispatchesRangeChanges = new WeakMap(), dispatchesChangesPropertyDescriptor = {
    get: function() {
     return ObjectsDispatchesRangeChanges.get(this);
    },
    set: function(value) {
     return ObjectsDispatchesRangeChanges.set(this, value);
    },
    configurable: !0,
    enumerable: !1
   };
   RangeChanges.prototype.addRangeChangeListener = function addRangeChangeListener(listener, token, beforeChange) {
    !this.isObservable && this.makeObservable && this.makeObservable();
    var listeners, descriptor = this.getRangeChangeDescriptor(token);
    (listeners = beforeChange ? descriptor.willChangeListeners : descriptor.changeListeners)._current ? Array.isArray(listeners._current) ? listeners._current.push(listener) : listeners._current = [ listeners._current, listener ] : listeners._current = listener, 
    void 0 === Object.getOwnPropertyDescriptor(this.__proto__ || Object.getPrototypeOf(this), "dispatchesRangeChanges") && Object.defineProperty(this.__proto__ || Object.getPrototypeOf(this), "dispatchesRangeChanges", dispatchesChangesPropertyDescriptor), 
    this.dispatchesRangeChanges = !0;
    var self = this;
    return function cancelRangeChangeListener() {
     self && (self.removeRangeChangeListener(listener, token, beforeChange), self = null);
    };
   }, RangeChanges.prototype.removeRangeChangeListener = function(listener, token, beforeChange) {
    var listeners, descriptor = this.getRangeChangeDescriptor(token);
    if ((listeners = beforeChange ? descriptor._willChangeListeners : descriptor._changeListeners)._current) {
     if (listeners._current === listener) {
      listeners._current = null;
     } else {
      var index = listeners._current.lastIndexOf(listener);
      if (-1 === index) {
       throw new Error("Can't remove range change listener: does not exist: token " + JSON.stringify(token));
      }
      descriptor.isActive ? (listeners.ghostCount = listeners.ghostCount + 1, listeners._current[index] = ListenerGhost) : listeners._current.spliceOne(index);
     }
    }
   }, RangeChanges.prototype.dispatchRangeChange = function(plus, minus, index, beforeChange) {
    var descriptor, listeners, tokenName, i, countI, listener, currentListeners, Ghost, descriptors = this.getAllRangeChangeDescriptors(), mapIter = descriptors.values();
    for (descriptors.dispatchBeforeChange = beforeChange; descriptor = mapIter.next().value; ) {
     if (descriptor.isActive) {
      return;
     }
     if ((listeners = beforeChange ? descriptor._willChangeListeners : descriptor._changeListeners) && listeners._current) {
      if (tokenName = listeners.specificHandlerMethodName, Array.isArray(listeners._current)) {
       if (listeners._current.length) {
        descriptor.isActive = !0;
        try {
         for (currentListeners = listeners.removeCurrentGostListenersIfNeeded(), Ghost = ListenerGhost, 
         i = 0, countI = currentListeners.length; i < countI; i++) {
          if ((listener = currentListeners[i]) !== Ghost) {
           if (listener[tokenName]) {
            listener[tokenName](plus, minus, index, this, beforeChange);
           } else {
            if (!listener.call) {
             throw new Error("Handler " + listener + " has no method " + tokenName + " and is not callable");
            }
            listener.call(this, plus, minus, index, this, beforeChange);
           }
          }
         }
        } finally {
         descriptor.isActive = !1;
        }
       }
      } else {
       descriptor.isActive = !0;
       try {
        if ((listener = listeners._current)[tokenName]) {
         listener[tokenName](plus, minus, index, this, beforeChange);
        } else {
         if (!listener.call) {
          throw new Error("Handler " + listener + " has no method " + tokenName + " and is not callable");
         }
         listener.call(this, plus, minus, index, this, beforeChange);
        }
       } finally {
        descriptor.isActive = !1;
       }
      }
     }
    }
   }, RangeChanges.prototype.addBeforeRangeChangeListener = function(listener, token) {
    return this.addRangeChangeListener(listener, token, !0);
   }, RangeChanges.prototype.removeBeforeRangeChangeListener = function(listener, token) {
    return this.removeRangeChangeListener(listener, token, !0);
   }, RangeChanges.prototype.dispatchBeforeRangeChange = function(plus, minus, index) {
    return this.dispatchRangeChange(plus, minus, index, !0);
   };
  }, {
   "../_map": 4,
   "../weak-map": 35,
   "./change-descriptor": 15
  } ],
  19: [ function(require, module, exports) {
   "use strict";
   require("./shim");
   var LruSet = require("./lru-set"), GenericCollection = require("./generic-collection"), GenericMap = require("./generic-map"), PropertyChanges = require("./listen/property-changes"), MapChanges = require("./listen/map-changes");
   function LruMap(values, maxLength, equals, hash, getDefault) {
    if (!(this instanceof LruMap)) {
     return new LruMap(values, maxLength, equals, hash, getDefault);
    }
    equals = equals || Object.equals, hash = hash || Object.hash, getDefault = getDefault || Function.noop, 
    this.contentEquals = equals, this.contentHash = hash, this.getDefault = getDefault, 
    this.store = new LruSet(void 0, maxLength, function keysEqual(a, b) {
     return equals(a.key, b.key);
    }, function keyHash(item) {
     return hash(item.key);
    }), this.length = 0, this.addEach(values);
   }
   module.exports = LruMap, LruMap.LruMap = LruMap, Object.addEach(LruMap.prototype, GenericCollection.prototype), 
   Object.addEach(LruMap.prototype, GenericMap.prototype), Object.addEach(LruMap.prototype, PropertyChanges.prototype), 
   Object.addEach(LruMap.prototype, MapChanges.prototype), Object.defineProperty(LruMap.prototype, "size", GenericCollection._sizePropertyDescriptor), 
   LruMap.from = GenericCollection.from, LruMap.prototype.constructClone = function(values) {
    return new this.constructor(values, this.maxLength, this.contentEquals, this.contentHash, this.getDefault);
   }, LruMap.prototype.log = function(charmap, stringify) {
    stringify = stringify || this.stringify, this.store.log(charmap, stringify);
   }, LruMap.prototype.stringify = function(item, leader) {
    return leader + JSON.stringify(item.key) + ": " + JSON.stringify(item.value);
   }, LruMap.prototype.addMapChangeListener = function() {
    if (!this.dispatchesMapChanges) {
     var self = this;
     this.store.addBeforeRangeChangeListener(function(plus, minus) {
      plus.length && minus.length && self.dispatchBeforeMapChange(minus[0].key, void 0);
     }), this.store.addRangeChangeListener(function(plus, minus) {
      plus.length && minus.length && self.dispatchMapChange(minus[0].key, void 0);
     });
    }
    MapChanges.prototype.addMapChangeListener.apply(this, arguments);
   };
  }, {
   "./generic-collection": 9,
   "./generic-map": 10,
   "./listen/map-changes": 16,
   "./listen/property-changes": 17,
   "./lru-set": 20,
   "./shim": 28
  } ],
  20: [ function(require, module, exports) {
   "use strict";
   require("./shim");
   var Set = require("./set").CollectionsSet, GenericCollection = require("./generic-collection"), GenericSet = require("./generic-set"), PropertyChanges = require("./listen/property-changes"), RangeChanges = require("./listen/range-changes");
   function LruSet(values, capacity, equals, hash, getDefault) {
    if (!(this instanceof LruSet)) {
     return new LruSet(values, capacity, equals, hash, getDefault);
    }
    capacity = capacity || 1 / 0, equals = equals || Object.equals, hash = hash || Object.hash, 
    getDefault = getDefault || Function.noop, this.store = new Set(void 0, equals, hash), 
    this.contentEquals = equals, this.contentHash = hash, this.getDefault = getDefault, 
    this.capacity = capacity, this.length = 0, this.addEach(values);
   }
   module.exports = LruSet, LruSet.LruSet = LruSet, Object.addEach(LruSet.prototype, GenericCollection.prototype), 
   Object.addEach(LruSet.prototype, GenericSet.prototype), Object.addEach(LruSet.prototype, PropertyChanges.prototype), 
   Object.addEach(LruSet.prototype, RangeChanges.prototype), Object.defineProperty(LruSet.prototype, "size", GenericCollection._sizePropertyDescriptor), 
   LruSet.from = GenericCollection.from, LruSet.prototype.constructClone = function(values) {
    return new this.constructor(values, this.capacity, this.contentEquals, this.contentHash, this.getDefault);
   }, LruSet.prototype.has = function(value) {
    return this.store.has(value);
   }, LruSet.prototype.get = function(value, equals) {
    if (equals) {
     throw new Error("LruSet#get does not support second argument: equals");
    }
    return void 0 !== (value = this.store.get(value)) ? (this.store.delete(value), this.store.add(value)) : value = this.getDefault(value), 
    value;
   }, LruSet.prototype.add = function(value) {
    var eldest, plus = [], minus = [];
    return this.store.has(value) ? (this.store.delete(value), this.store.add(value)) : this.capacity > 0 && (plus.push(value), 
    this.length >= this.capacity && (eldest = this.store.order.head.next, minus.push(eldest.value)), 
    this.dispatchesRangeChanges && this.dispatchBeforeRangeChange(plus, minus, 0), this.store.add(value), 
    minus.length > 0 && this.store.delete(eldest.value), this.length = this.length + plus.length - minus.length, 
    this.dispatchesRangeChanges && this.dispatchRangeChange(plus, minus, 0)), plus.length !== minus.length;
   }, LruSet.prototype.delete = function(value, equals) {
    if (equals) {
     throw new Error("LruSet#delete does not support second argument: equals");
    }
    var found = this.store.has(value);
    return found && (this.dispatchesRangeChanges && this.dispatchBeforeRangeChange([], [ value ], 0), 
    this.store.delete(value), this.length--, this.dispatchesRangeChanges && this.dispatchRangeChange([], [ value ], 0)), 
    found;
   }, LruSet.prototype.one = function() {
    if (this.length > 0) {
     return this.store.one();
    }
   }, LruSet.prototype.clear = function() {
    this.store.clear(), this.length = 0;
   }, LruSet.prototype.reduce = function(callback, basis) {
    var thisp = arguments[2], index = 0;
    return this.store.reduce(function(basis, value) {
     return callback.call(thisp, basis, value, index++, this);
    }, basis, this);
   }, LruSet.prototype.reduceRight = function(callback, basis) {
    var thisp = arguments[2], set = this.store, index = this.length - 1;
    return set.reduceRight(function(basis, value) {
     return callback.call(thisp, basis, value, index--, this);
    }, basis, this);
   }, LruSet.prototype.iterate = function() {
    return this.store.iterate();
   };
  }, {
   "./generic-collection": 9,
   "./generic-set": 12,
   "./listen/property-changes": 17,
   "./listen/range-changes": 18,
   "./set": 23,
   "./shim": 28
  } ],
  21: [ function(require, module, exports) {
   (function(global) {
    "use strict";
    var Map = require("./_map"), PropertyChanges = require("./listen/property-changes"), MapChanges = require("./listen/map-changes");
    module.exports = Map, void 0 === global.Map || "function" != typeof global.Set.prototype.values ? (Object.addEach(Map.prototype, PropertyChanges.prototype), 
    Object.addEach(Map.prototype, MapChanges.prototype)) : (Object.defineEach(Map.prototype, PropertyChanges.prototype, !1, !0, !1, !0), 
    Object.defineEach(Map.prototype, MapChanges.prototype, !1, !0, !1, !0));
   }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
  }, {
   "./_map": 4,
   "./listen/map-changes": 16,
   "./listen/property-changes": 17
  } ],
  22: [ function(require, module, exports) {
   "use strict";
   var Map = require("./map").Map;
   function MultiMap(values, bucket, equals, hash) {
    if (!(this instanceof MultiMap)) {
     return new MultiMap(values, bucket, equals, hash);
    }
    this.bucket = bucket || this.bucket, new (Function.prototype.bind.call(Map, this, values, equals, hash, function getDefault(key) {
     var bucket = this.bucket(key);
     return Map.prototype.set.call(this, key, bucket), bucket;
    }))();
   }
   module.exports = MultiMap, MultiMap.MultiMap = MultiMap, MultiMap.prototype = Object.create(Map.prototype), 
   MultiMap.prototype.constructor = MultiMap, MultiMap.prototype.constructClone = function(values) {
    return new this.constructor(values, this.bucket, this.contentEquals, this.contentHash);
   }, MultiMap.prototype.set = function(key, newValues) {
    var values = this.get(key);
    values.swap(0, values.length, newValues);
   }, MultiMap.prototype.bucket = function(key) {
    return [];
   };
  }, {
   "./map": 21
  } ],
  23: [ function(require, module, exports) {
   (function(global) {
    "use strict";
    var GlobalSet, Set = require("./_set"), PropertyChanges = require("./listen/property-changes"), RangeChanges = require("./listen/range-changes"), MapChanges = require("./listen/map-changes"), SIZE = "size";
    if (void 0 !== global.Set && "function" == typeof global.Set.prototype.values) {
     var set_makeObservable;
     GlobalSet = global.Set, module.exports = Set, set_makeObservable = {}.__proto__ === Object.prototype ? function() {
      this.__proto__ = ChangeDispatchSet;
     } : function() {
      Object.defineProperties(this, observableSetProperties);
     }, Object.defineProperty(GlobalSet.prototype, "makeObservable", {
      value: set_makeObservable,
      writable: !0,
      configurable: !0,
      enumerable: !1
     });
     var set_clear = GlobalSet.prototype.clear, set_add = GlobalSet.prototype.add, set_delete = GlobalSet.prototype.delete, observableSetProperties = {
      _dispatchEmptyArray: {
       value: []
      },
      clear: {
       value: function() {
        var clearing, size = this.size;
        size && this.dispatchBeforeOwnPropertyChange(SIZE, size), this.dispatchesRangeChanges && (clearing = this.toArray(), 
        this.dispatchBeforeRangeChange(this._dispatchEmptyArray, clearing, 0)), set_clear.call(this), 
        this.dispatchesRangeChanges && this.dispatchRangeChange(this._dispatchEmptyArray, clearing, 0), 
        size && this.dispatchOwnPropertyChange(SIZE, 0);
       },
       writable: !0,
       configurable: !0
      },
      add: {
       value: function(value) {
        if (!this.has(value)) {
         var index = this.size, dispatchValueArray = [ value ];
         return this.dispatchBeforeOwnPropertyChange(SIZE, index), this.dispatchesRangeChanges && this.dispatchBeforeRangeChange(dispatchValueArray, this._dispatchEmptyArray, index), 
         set_add.call(this, value), this.dispatchesRangeChanges && this.dispatchRangeChange(dispatchValueArray, this._dispatchEmptyArray, index), 
         this.dispatchOwnPropertyChange(SIZE, index + 1), !0;
        }
        return !1;
       },
       writable: !0,
       configurable: !0
      },
      delete: {
       value: function(value, index) {
        if (this.has(value)) {
         var size = this.size;
         if (void 0 === index) {
          var setIterator = this.values();
          for (index = 0; setIterator.next().value !== value; ) {
           index++;
          }
         }
         this.dispatchBeforeOwnPropertyChange(SIZE, size);
         var dispatchValueArray = [ value ];
         return this.dispatchesRangeChanges && this.dispatchBeforeRangeChange(this._dispatchEmptyArray, dispatchValueArray, index), 
         set_delete.call(this, value), this.dispatchesRangeChanges && this.dispatchRangeChange(this._dispatchEmptyArray, dispatchValueArray, index), 
         this.dispatchOwnPropertyChange(SIZE, size - 1), !0;
        }
        return !1;
       }
      }
     }, ChangeDispatchSet = Object.create(GlobalSet.prototype, observableSetProperties);
     Object.defineEach(Set.prototype, PropertyChanges.prototype, !1, !0, !1, !0), Object.defineProperty(Set.prototype, "makePropertyObservable", {
      value: function() {},
      writable: !0,
      configurable: !0,
      enumerable: !1
     }), Object.defineEach(Set.prototype, RangeChanges.prototype, !1, !0, !1, !0), Object.defineEach(Set.prototype, MapChanges.prototype, !1, !0, !1, !0), 
     Object.defineProperty(Set, "_setupCollectionSet", {
      value: setupCollectionSet,
      writable: !0,
      configurable: !0,
      enumerable: !1
     });
    } else {
     setupCollectionSet();
    }
    function setupCollectionSet() {
     var _CollectionsSet = Set.CollectionsSet, CollectionsSet = function CollectionsSet(values, equals, hash, getDefault) {
      return _CollectionsSet._init(CollectionsSet, this, values, equals, hash, getDefault);
     };
     CollectionsSet.Set = CollectionsSet, CollectionsSet.from = _CollectionsSet.from, 
     Set.CollectionsSet = CollectionsSet, (CollectionsSet.prototype = new _CollectionsSet()).constructor = CollectionsSet;
     var List = require("./list"), FastSet = require("./fast-set");
     CollectionsSet.prototype.Order = List, CollectionsSet.prototype.Store = FastSet, 
     Object.defineProperty(CollectionsSet.prototype, "_dispatchEmptyArray", {
      value: []
     }), CollectionsSet.prototype.add = function(value) {
      var node = new this.order.Node(value);
      if (!this.store.has(node)) {
       var index = this.length, dispatchValueArray = [ value ];
       return this.dispatchBeforeOwnPropertyChange(SIZE, index), this.dispatchesRangeChanges && this.dispatchBeforeRangeChange(dispatchValueArray, this._dispatchEmptyArray, index), 
       this.order.add(value), node = this.order.head.prev, this.store.add(node), this.length++, 
       this.dispatchesRangeChanges && this.dispatchRangeChange(dispatchValueArray, this._dispatchEmptyArray, index), 
       this.dispatchOwnPropertyChange(SIZE, index + 1), !0;
      }
      return !1;
     }, CollectionsSet.prototype.delete = function(value, equals) {
      if (equals) {
       throw new Error("Set#delete does not support second argument: equals");
      }
      var node = new this.order.Node(value);
      if (this.store.has(node)) {
       node = this.store.get(node);
       var dispatchValueArray = [ value ];
       return this.dispatchBeforeOwnPropertyChange(SIZE, this.length), this.dispatchesRangeChanges && this.dispatchBeforeRangeChange(this._dispatchEmptyArray, dispatchValueArray, node.index), 
       this.store.delete(node), this.order.splice(node, 1), this.length--, this.dispatchesRangeChanges && this.dispatchRangeChange(this._dispatchEmptyArray, dispatchValueArray, node.index), 
       this.dispatchOwnPropertyChange(SIZE, this.length), !0;
      }
      return !1;
     }, CollectionsSet.prototype.clear = function() {
      var clearing, length = this.length;
      length && this.dispatchBeforeOwnPropertyChange(SIZE, length), this.dispatchesRangeChanges && (clearing = this.toArray(), 
      this.dispatchBeforeRangeChange(this._dispatchEmptyArray, clearing, 0)), this._clear(), 
      this.dispatchesRangeChanges && this.dispatchRangeChange(this._dispatchEmptyArray, clearing, 0), 
      length && this.dispatchOwnPropertyChange(SIZE, 0);
     }, Object.addEach(Set.CollectionsSet.prototype, PropertyChanges.prototype), Object.addEach(Set.CollectionsSet.prototype, RangeChanges.prototype), 
     Set.CollectionsSet.prototype.makeObservable = function() {
      this.order.makeObservable();
     }, module.exports = CollectionsSet;
    }
   }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
  }, {
   "./_set": 5,
   "./fast-set": 8,
   "./list": 14,
   "./listen/map-changes": 16,
   "./listen/property-changes": 17,
   "./listen/range-changes": 18
  } ],
  24: [ function(require, module, exports) {
   "use strict";
   require("./shim-function");
   var GenericCollection = require("./generic-collection"), GenericOrder = require("./generic-order"), WeakMap = require("./weak-map");
   module.exports = Array;
   var array_splice = Array.prototype.splice, array_slice = Array.prototype.slice;
   function define(key, value) {
    Object.defineProperty(Array.prototype, key, {
     value: value,
     writable: !0,
     configurable: !0,
     enumerable: !1
    });
   }
   Array.empty = [], Object.freeze && Object.freeze(Array.empty), Array.from = function(values) {
    var array = [];
    return array.addEach(values), array;
   }, Array.unzip = function(table) {
    for (var transpose = [], length = 1 / 0, i = 0; i < table.length; i++) {
     var row = table[i];
     table[i] = row.toArray(), row.length < length && (length = row.length);
    }
    for (i = 0; i < table.length; i++) {
     row = table[i];
     for (var j = 0; j < row.length; j++) {
      j < length && j in row && (transpose[j] = transpose[j] || [], transpose[j][i] = row[j]);
     }
    }
    return transpose;
   }, define("addEach", GenericCollection.prototype.addEach), define("deleteEach", GenericCollection.prototype.deleteEach), 
   define("toArray", GenericCollection.prototype.toArray), define("toObject", GenericCollection.prototype.toObject), 
   define("all", GenericCollection.prototype.all), define("any", GenericCollection.prototype.any), 
   define("min", GenericCollection.prototype.min), define("max", GenericCollection.prototype.max), 
   define("sum", GenericCollection.prototype.sum), define("average", GenericCollection.prototype.average), 
   define("only", GenericCollection.prototype.only), define("flatten", GenericCollection.prototype.flatten), 
   define("zip", GenericCollection.prototype.zip), define("enumerate", GenericCollection.prototype.enumerate), 
   define("group", GenericCollection.prototype.group), define("sorted", GenericCollection.prototype.sorted), 
   define("reversed", GenericCollection.prototype.reversed), define("constructClone", function(values) {
    var clone = new this.constructor();
    return clone.addEach(values), clone;
   }), define("has", function(value, equals) {
    return -1 !== this.findValue(value, equals);
   }), define("get", function(index, defaultValue) {
    if (+index !== index) {
     throw new Error("Indicies must be numbers");
    }
    return !index in this ? defaultValue : this[index];
   }), define("set", function(index, value) {
    return this[index] = value, !0;
   }), define("add", function(value) {
    return this.push(value), !0;
   }), define("delete", function(value, equals) {
    var index = this.findValue(value, equals);
    return -1 !== index && (this.spliceOne(index), !0);
   }), define("deleteAll", function(value, equals) {
    equals = equals || this.contentEquals || Object.equals;
    for (var count = 0, index = 0; index < this.length; ) {
     equals(value, this[index]) ? (this.swap(index, 1), count++) : index++;
    }
    return count;
   }), Array.prototype.find || define("find", function(predicate) {
    if (null == this) {
     throw new TypeError('"this" is null or not defined');
    }
    var o = Object(this), len = o.length >>> 0;
    if ('function' != typeof predicate) {
     throw new TypeError('predicate must be a function');
    }
    for (var thisArg = arguments[1], k = 0; k < len; ) {
     var kValue = o[k];
     if (predicate.call(thisArg, kValue, k, o)) {
      return kValue;
     }
     k++;
    }
   });
   var deprecatedWarnNonce = {};
   function deprecatedWarn(msg, notOnce) {
    'undefined' != typeof console && 'function' == typeof console.warn && !0 !== notOnce && !1 === deprecatedWarnNonce.hasOwnProperty(msg) && deprecatedWarnNonce[msg]++;
   }
   var ArrayFindPrototype = Object.getOwnPropertyDescriptor(Array.prototype, 'find').value;
   function ArrayIterator(array, start, end) {
    this.array = array, this.start = null == start ? 0 : start, this.end = end;
   }
   define("find", function(value, equals, index) {
    return 'function' == typeof arguments[0] && this instanceof Array ? ArrayFindPrototype.apply(this, arguments) : (deprecatedWarn('Array#find usage is deprecated please use Array#findValue'), 
    this.findValue.apply(this, arguments));
   }), define("findValue", function(value, equals, index) {
    if (index) {
     throw new Error("Array#findValue does not support third argument: index");
    }
    equals = equals || this.contentEquals || Object.equals;
    for (index = 0; index < this.length; index++) {
     if (index in this && equals(value, this[index])) {
      return index;
     }
    }
    return -1;
   }), define("findLast", function(value, equals) {
    return deprecatedWarn('Array#findLast function is deprecated please use Array#findLastValue instead.'), 
    this.findLastValue.apply(this, arguments);
   }), define("findLastValue", function(value, equals) {
    equals = equals || this.contentEquals || Object.equals;
    var index = this.length;
    do {
     if (--index in this && equals(this[index], value)) {
      return index;
     }
    } while (index > 0);
    return -1;
   }), define("swap", function(start, length, plus) {
    var args, plusLength, i, j, returnValue;
    if (start > this.length && (this.length = start), void 0 !== plus) {
     if (args = [ start, length ], Array.isArray(plus) || (plus = array_slice.call(plus)), 
     i = 0, (plusLength = plus.length) < 1e3) {
      for (;i < plusLength; i++) {
       args[i + 2] = plus[i];
      }
      return array_splice.apply(this, args);
     }
     for (returnValue = array_splice.apply(this, args); i < plusLength; ) {
      for (args = [ start + i, 0 ], j = 2; j < 1002 && i < plusLength; j++, i++) {
       args[j] = plus[i];
      }
      array_splice.apply(this, args);
     }
     return returnValue;
    }
    return void 0 !== length ? array_splice.call(this, start, length) : void 0 !== start ? array_splice.call(this, start) : [];
   }), define("peek", function() {
    return this[0];
   }), define("poke", function(value) {
    this.length > 0 && (this[0] = value);
   }), define("peekBack", function() {
    if (this.length > 0) {
     return this[this.length - 1];
    }
   }), define("pokeBack", function(value) {
    this.length > 0 && (this[this.length - 1] = value);
   }), define("one", function() {
    for (var i in this) {
     if (Object.owns(this, i)) {
      return this[i];
     }
    }
   }), Array.prototype.clear || define("clear", function() {
    return this.length = 0, this;
   }), define("compare", function(that, compare) {
    var i, length, relative;
    if (compare = compare || Object.compare, this === that) {
     return 0;
    }
    if (!that || !Array.isArray(that)) {
     return GenericOrder.prototype.compare.call(this, that, compare);
    }
    for (length = this.length < that.length ? this.length : that.length, i = 0; i < length; i++) {
     if (i in this) {
      if (!(i in that)) {
       return -1;
      }
      if (relative = compare(this[i], that[i])) {
       return relative;
      }
     } else if (i in that) {
      return 1;
     }
    }
    return this.length - that.length;
   }), define("equals", function(that, equals) {
    equals = equals || Object.equals;
    var i = 0, length = this.length;
    if (this === that) {
     return !0;
    }
    if (!that || !Array.isArray(that)) {
     return GenericOrder.prototype.equals.call(this, that);
    }
    if (length !== that.length) {
     return !1;
    }
    for (;i < length; ++i) {
     if (i in this) {
      if (!(i in that)) {
       return !1;
      }
      if (!equals(this[i], that[i])) {
       return !1;
      }
     } else if (i in that) {
      return !1;
     }
    }
    return !0;
   }), define("clone", function(depth, memo) {
    if (null == depth) {
     depth = 1 / 0;
    } else if (0 === depth) {
     return this;
    }
    if ((memo = memo || new WeakMap()).has(this)) {
     return memo.get(this);
    }
    var clone = new Array(this.length);
    for (var i in memo.set(this, clone), this) {
     clone[i] = Object.clone(this[i], depth - 1, memo);
    }
    return clone;
   }), define("iterate", function(start, end) {
    return new ArrayIterator(this, start, end);
   }), void 0 === Array.prototype.spliceOne && define("spliceOne", function(index, itemToAdd) {
    var len = this.length;
    if (len) {
     if (1 === arguments.length) {
      for (;index < len; ) {
       this[index] = this[index + 1], index++;
      }
      this.length--;
     } else {
      this[index] = itemToAdd;
     }
    }
   }), define("Iterator", ArrayIterator), ArrayIterator.prototype.__iterationObject = null, 
   Object.defineProperty(ArrayIterator.prototype, "_iterationObject", {
    get: function() {
     return this.__iterationObject || (this.__iterationObject = {
      done: !1,
      value: null
     });
    }
   }), ArrayIterator.prototype.next = function() {
    return this.start === (null == this.end ? this.array.length : this.end) ? (this._iterationObject.done = !0, 
    this._iterationObject.value = void 0) : this._iterationObject.value = this.array[this.start++], 
    this._iterationObject;
   };
  }, {
   "./generic-collection": 9,
   "./generic-order": 11,
   "./shim-function": 25,
   "./weak-map": 35
  } ],
  25: [ function(require, module, exports) {
   module.exports = Function, Function.noop = function() {}, Function.identity = function(value) {
    return value;
   }, Function.by = function(by, compare) {
    compare = compare || Object.compare, by = by || Function.identity;
    var compareBy = function(a, b) {
     return compare(by(a), by(b));
    };
    return compareBy.compare = compare, compareBy.by = by, compareBy;
   }, Function.get = function(key) {
    return function(object) {
     return Object.get(object, key);
    };
   };
  }, {} ],
  26: [ function(require, module, exports) {
   "use strict";
   var WeakMap = require("./weak-map");
   require("./shim-function"), module.exports = Object, Object.empty = Object.freeze(Object.create(null)), 
   Object.isObject = function(object) {
    return Object(object) === object;
   }, Object.getValueOf = function(value) {
    return value && "function" == typeof value.valueOf && (value = value.valueOf()), 
    value;
   };
   var hashMap = new WeakMap();
   Object.hash = function(object) {
    return object && "function" == typeof object.hash ? "" + object.hash() : Object(object) === object ? (hashMap.has(object) || hashMap.set(object, Math.random().toString(36).slice(2)), 
    hashMap.get(object)) : "" + object;
   };
   var owns = Object.prototype.hasOwnProperty;
   Object.owns = function(object, key) {
    return owns.call(object, key);
   }, Object.has = function(object, key) {
    if ("object" != typeof object) {
     throw new Error("Object.has can't accept non-object: " + typeof object);
    }
    if (object && "function" == typeof object.has) {
     return object.has(key);
    }
    if ("string" == typeof key) {
     return key in object && object[key] !== Object.prototype[key];
    }
    throw new Error("Key must be a string for Object.has on plain objects");
   }, Object.get = function(object, key, value) {
    if ("object" != typeof object) {
     throw new Error("Object.get can't accept non-object: " + typeof object);
    }
    return object && "function" == typeof object.get ? object.get(key, value) : Object.has(object, key) ? object[key] : value;
   }, Object.set = function(object, key, value) {
    object && "function" == typeof object.set ? object.set(key, value) : object[key] = value;
   }, Object.addEach = function(target, source, overrides) {
    var overridesExistingProperty = 3 !== arguments.length || overrides;
    if (source) {
     if ("function" != typeof source.forEach || source.hasOwnProperty("forEach")) {
      if ("number" == typeof source.length) {
       for (var index = 0; index < source.length; index++) {
        target[index] = source[index];
       }
      } else {
       for (var key, keys = Object.keys(source), i = 0; key = keys[i]; i++) {
        !overridesExistingProperty && Object.owns(target, key) || (target[key] = source[key]);
       }
      }
     } else {
      !0 === source.isMap ? source.forEach(function(value, key) {
       target[key] = value;
      }) : source.forEach(function(pair) {
       target[pair[0]] = pair[1];
      });
     }
    } else {}
    return target;
   }, Object.defineEach = function(target, source, overrides, configurable, enumerable, writable) {
    var overridesExistingProperty = 3 !== arguments.length || overrides;
    if (source) {
     if ("function" != typeof source.forEach || source.hasOwnProperty("forEach")) {
      if ("number" == typeof source.length) {
       for (var index = 0; index < source.length; index++) {
        Object.defineProperty(target, index, {
         value: source[index],
         writable: writable,
         configurable: configurable,
         enumerable: enumerable
        });
       }
      } else {
       for (var key, keys = Object.keys(source), i = 0; key = keys[i]; i++) {
        !overridesExistingProperty && Object.owns(target, key) || Object.defineProperty(target, key, {
         value: source[key],
         writable: writable,
         configurable: configurable,
         enumerable: enumerable
        });
       }
      }
     } else {
      !0 === source.isMap ? source.forEach(function(value, key) {
       Object.defineProperty(target, key, {
        value: value,
        writable: writable,
        configurable: configurable,
        enumerable: enumerable
       });
      }) : source.forEach(function(pair) {
       Object.defineProperty(target, pair[0], {
        value: pair[1],
        writable: writable,
        configurable: configurable,
        enumerable: enumerable
       });
      });
     }
    } else {}
    return target;
   }, Object.forEach = function(object, callback, thisp) {
    for (var iKey, keys = Object.keys(object), i = 0; iKey = keys[i]; i++) {
     callback.call(thisp, object[iKey], iKey, object);
    }
   }, Object.map = function(object, callback, thisp) {
    for (var iKey, keys = Object.keys(object), i = 0, result = []; iKey = keys[i]; i++) {
     result.push(callback.call(thisp, object[iKey], iKey, object));
    }
    return result;
   }, Object.values = function(object) {
    return Object.map(object, Function.identity);
   }, Object.concat = function() {
    for (var object = {}, i = 0; i < arguments.length; i++) {
     Object.addEach(object, arguments[i]);
    }
    return object;
   }, Object.from = Object.concat, Object.is = function(x, y) {
    return x === y ? 0 !== x || 1 / x == 1 / y : x != x && y != y;
   }, Object.equals = function(a, b, equals, memo) {
    if (equals = equals || Object.equals, (a = Object.getValueOf(a)) === (b = Object.getValueOf(b))) {
     return !0;
    }
    if (Object.isObject(a)) {
     if ((memo = memo || new WeakMap()).has(a)) {
      return !0;
     }
     memo.set(a, !0);
    }
    if (Object.isObject(a) && "function" == typeof a.equals) {
     return a.equals(b, equals, memo);
    }
    if (Object.isObject(b) && "function" == typeof b.equals) {
     return b.equals(a, equals, memo);
    }
    if (Object.isObject(a) && Object.isObject(b) && Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {
     for (var name in a) {
      if (!equals(a[name], b[name], equals, memo)) {
       return !1;
      }
     }
     for (var name in b) {
      if (!(name in a && equals(b[name], a[name], equals, memo))) {
       return !1;
      }
     }
     return !0;
    }
    return a != a && b != b || (!a || !b) && a === b;
   }, Object.compare = function(a, b) {
    if ((a = Object.getValueOf(a)) === (b = Object.getValueOf(b))) {
     return 0;
    }
    var aType = typeof a, bType = typeof b;
    return "number" === aType && "number" === bType ? a - b : "string" === aType && "string" === bType ? a < b ? -1 / 0 : 1 / 0 : a && "function" == typeof a.compare ? a.compare(b) : b && "function" == typeof b.compare ? -b.compare(a) : 0;
   }, Object.clone = function(value, depth, memo) {
    if (value = Object.getValueOf(value), memo = memo || new WeakMap(), void 0 === depth) {
     depth = 1 / 0;
    } else if (0 === depth) {
     return value;
    }
    if (Object.isObject(value)) {
     if (!memo.has(value)) {
      if (value && "function" == typeof value.clone) {
       memo.set(value, value.clone(depth, memo));
      } else {
       var prototype = Object.getPrototypeOf(value);
       if (null !== prototype && prototype !== Object.prototype) {
        throw new Error("Can't clone " + value);
       }
       var clone = Object.create(prototype);
       for (var key in memo.set(value, clone), value) {
        clone[key] = Object.clone(value[key], depth - 1, memo);
       }
      }
     }
     return memo.get(value);
    }
    return value;
   }, Object.clear = function(object) {
    if (object && "function" == typeof object.clear) {
     object.clear();
    } else {
     for (var keys = Object.keys(object), i = keys.length; i; ) {
      delete object[keys[--i]];
     }
    }
    return object;
   };
  }, {
   "./shim-function": 25,
   "./weak-map": 35
  } ],
  27: [ function(require, module, exports) {
   if (!RegExp.escape) {
    var special = /[-[\]{}()*+?.\\^$|,#\s]/g;
    RegExp.escape = function(string) {
     return string.replace(special, "\\$&");
    };
   }
  }, {} ],
  28: [ function(require, module, exports) {
   require("./shim-array"), require("./shim-object"), require("./shim-function"), require("./shim-regexp");
  }, {
   "./shim-array": 24,
   "./shim-function": 25,
   "./shim-object": 26,
   "./shim-regexp": 27
  } ],
  29: [ function(require, module, exports) {
   "use strict";
   require("./shim");
   var SortedArraySet = require("./sorted-array-set"), GenericCollection = require("./generic-collection"), GenericMap = require("./generic-map"), PropertyChanges = require("./listen/property-changes"), MapChanges = require("./listen/map-changes");
   function SortedArrayMap(values, equals, compare, getDefault) {
    if (!(this instanceof SortedArrayMap)) {
     return new SortedArrayMap(values, equals, compare, getDefault);
    }
    equals = equals || Object.equals, compare = compare || Object.compare, getDefault = getDefault || Function.noop, 
    this.contentEquals = equals, this.contentCompare = compare, this.getDefault = getDefault, 
    this.store = new SortedArraySet(null, function keysEqual(a, b) {
     return equals(a.key, b.key);
    }, function compareKeys(a, b) {
     return compare(a.key, b.key);
    }), this.length = 0, this.addEach(values);
   }
   module.exports = SortedArrayMap, SortedArrayMap.SortedArrayMap = SortedArrayMap, 
   Object.addEach(SortedArrayMap.prototype, GenericCollection.prototype), Object.addEach(SortedArrayMap.prototype, GenericMap.prototype), 
   Object.addEach(SortedArrayMap.prototype, PropertyChanges.prototype), Object.addEach(SortedArrayMap.prototype, MapChanges.prototype), 
   SortedArrayMap.from = GenericCollection.from, SortedArrayMap.prototype.isSorted = !0, 
   SortedArrayMap.prototype.constructClone = function(values) {
    return new this.constructor(values, this.contentEquals, this.contentCompare, this.getDefault);
   };
  }, {
   "./generic-collection": 9,
   "./generic-map": 10,
   "./listen/map-changes": 16,
   "./listen/property-changes": 17,
   "./shim": 28,
   "./sorted-array-set": 30
  } ],
  30: [ function(require, module, exports) {
   "use strict";
   module.exports = SortedArraySet;
   require("./shim");
   var SortedArray = require("./sorted-array"), GenericSet = require("./generic-set"), PropertyChanges = require("./listen/property-changes");
   function SortedArraySet(values, equals, compare, getDefault) {
    if (!(this instanceof SortedArraySet)) {
     return new SortedArraySet(values, equals, compare, getDefault);
    }
    SortedArray.call(this, values, equals, compare, getDefault);
   }
   SortedArraySet.SortedArraySet = SortedArraySet, SortedArraySet.prototype = Object.create(SortedArray.prototype), 
   SortedArraySet.prototype.constructor = SortedArraySet, Object.addEach(SortedArraySet.prototype, GenericSet.prototype), 
   Object.addEach(SortedArraySet.prototype, PropertyChanges.prototype), SortedArraySet.from = SortedArray.from, 
   SortedArraySet.prototype.isSorted = !0, SortedArraySet.prototype.add = function(value) {
    return !this.has(value) && (SortedArray.prototype.add.call(this, value), !0);
   }, SortedArraySet.prototype.reduce = function(callback, basis) {
    var self = this, thisp = arguments[2];
    return this.array.reduce(function(basis, value, index) {
     return callback.call(thisp, basis, value, index, self);
    }, basis);
   }, SortedArraySet.prototype.reduceRight = function(callback, basis) {
    var self = this, thisp = arguments[2];
    return this.array.reduceRight(function(basis, value, index) {
     return callback.call(thisp, basis, value, index, self);
    }, basis);
   };
  }, {
   "./generic-set": 12,
   "./listen/property-changes": 17,
   "./shim": 28,
   "./sorted-array": 31
  } ],
  31: [ function(require, module, exports) {
   "use strict";
   module.exports = SortedArray;
   require("./shim");
   var GenericCollection = require("./generic-collection"), PropertyChanges = require("./listen/property-changes"), RangeChanges = require("./listen/range-changes");
   function SortedArray(values, equals, compare, getDefault) {
    if (!(this instanceof SortedArray)) {
     return new SortedArray(values, equals, compare, getDefault);
    }
    Array.isArray(values) ? (this.array = values, values = values.splice(0, values.length)) : this.array = [], 
    this.contentEquals = equals || Object.equals, this.contentCompare = compare || Object.compare, 
    this.getDefault = getDefault || Function.noop, this.length = 0, this.addEach(values);
   }
   function search(array, value, compare) {
    for (var first = 0, last = array.length - 1; first <= last; ) {
     var middle = first + last >> 1, comparison = compare(value, array[middle]);
     if (comparison > 0) {
      first = middle + 1;
     } else {
      if (!(comparison < 0)) {
       return middle;
      }
      last = middle - 1;
     }
    }
    return -(first + 1);
   }
   function determineIncomparableRange(index, array, value, compare, equals) {
    for (var start = index, end = index; start > 0 && 0 === compare(value, array[start - 1]); ) {
     start--;
    }
    for (;end < array.length - 1 && 0 === compare(value, array[end + 1]); ) {
     end++;
    }
    return {
     start: start,
     end: end
    };
   }
   function searchFirst(array, value, compare, equals) {
    var index = search(array, value, compare);
    if (index < 0) {
     return -1;
    }
    for (var range = determineIncomparableRange(index, array, value, compare), i = range.start; i <= range.end; i++) {
     if (equals(value, array[i])) {
      return i;
     }
    }
    return -1;
   }
   function searchLast(array, value, compare, equals) {
    var index = search(array, value, compare);
    if (index < 0) {
     return -1;
    }
    for (var range = determineIncomparableRange(index, array, value, compare), i = range.end; i >= range.start; i--) {
     if (equals(value, array[i])) {
      return i;
     }
    }
    return -1;
   }
   function searchForInsertionIndex(array, value, compare) {
    var index = search(array, value, compare);
    if (index < 0) {
     return -index - 1;
    }
    for (var last = array.length - 1; index < last && 0 === compare(value, array[index + 1]); ) {
     index++;
    }
    return index;
   }
   SortedArray.SortedArray = SortedArray, SortedArray.from = GenericCollection.from, 
   Object.addEach(SortedArray.prototype, GenericCollection.prototype), Object.addEach(SortedArray.prototype, PropertyChanges.prototype), 
   Object.addEach(SortedArray.prototype, RangeChanges.prototype), SortedArray.prototype.isSorted = !0, 
   SortedArray.prototype.constructClone = function(values) {
    return new this.constructor(values, this.contentEquals, this.contentCompare, this.getDefault);
   }, SortedArray.prototype.has = function(value, equals) {
    if (equals) {
     throw new Error("SortedSet#has does not support second argument: equals");
    }
    return -1 !== searchFirst(this.array, value, this.contentCompare, this.contentEquals);
   }, SortedArray.prototype.get = function(value, equals) {
    if (equals) {
     throw new Error("SortedArray#get does not support second argument: equals");
    }
    var index = searchFirst(this.array, value, this.contentCompare, this.contentEquals);
    return -1 !== index ? this.array[index] : this.getDefault(value);
   }, SortedArray.prototype.add = function(value) {
    var index = searchForInsertionIndex(this.array, value, this.contentCompare);
    return this.dispatchesRangeChanges && this.dispatchBeforeRangeChange([ value ], Array.empty, index), 
    this.array.splice(index, 0, value), this.length++, this.dispatchesRangeChanges && this.dispatchRangeChange([ value ], Array.empty, index), 
    !0;
   }, SortedArray.prototype.delete = function(value, equals) {
    if (equals) {
     throw new Error("SortedArray#delete does not support second argument: equals");
    }
    var index = searchFirst(this.array, value, this.contentCompare, this.contentEquals);
    return -1 !== index && (this.dispatchesRangeChanges && this.dispatchBeforeRangeChange(Array.empty, [ value ], index), 
    this.array.spliceOne(index), this.length--, this.dispatchesRangeChanges && this.dispatchRangeChange(Array.empty, [ value ], index), 
    !0);
   }, SortedArray.prototype.deleteAll = function(value, equals) {
    if (equals) {
     var count = this.array.deleteAll(value, equals);
     return this.length -= count, count;
    }
    var start = searchFirst(this.array, value, this.contentCompare, this.contentEquals);
    if (-1 !== start) {
     for (var end = start; this.contentEquals(value, this.array[end]); ) {
      end++;
     }
     var minus = this.slice(start, end);
     return this.dispatchesRangeChanges && this.dispatchBeforeRangeChange(Array.empty, minus, start), 
     this.array.splice(start, minus.length), this.length -= minus.length, this.dispatchesRangeChanges && this.dispatchRangeChange(Array.empty, minus, start), 
     minus.length;
    }
    return 0;
   }, SortedArray.prototype.indexOf = function(value) {
    return searchFirst(this.array, value, this.contentCompare, this.contentEquals);
   }, SortedArray.prototype.lastIndexOf = function(value) {
    return searchLast(this.array, value, this.contentCompare, this.contentEquals);
   };
   var deprecatedWarnNonce = {};
   function deprecatedWarn(msg, notOnce) {
    'undefined' != typeof console && 'function' == typeof console.warn && !0 !== notOnce && !1 === deprecatedWarnNonce.hasOwnProperty(msg) && deprecatedWarnNonce[msg]++;
   }
   SortedArray.prototype.find = function(value, equals, index) {
    return deprecatedWarn('This SortedArray#find usage is deprecated please use SortedArray#findValue'), 
    this.findValue.apply(this, arguments);
   }, SortedArray.prototype.findValue = function(value, equals, index) {
    if (equals) {
     throw new Error("SortedArray#findValue does not support second argument: equals");
    }
    if (index) {
     throw new Error("SortedArray#findValue does not support third argument: index");
    }
    return searchFirst(this.array, value, this.contentCompare, this.contentEquals);
   }, SortedArray.prototype.findLast = function(value, equals, index) {
    return deprecatedWarn('This SortedArray#findLast usage is deprecated please use SortedArray#findLastValue'), 
    this.findLastValue.apply(this, arguments);
   }, SortedArray.prototype.findLastValue = function(value, equals, index) {
    if (equals) {
     throw new Error("SortedArray#findLastValue does not support second argument: equals");
    }
    if (index) {
     throw new Error("SortedArray#findLastValue does not support third argument: index");
    }
    return searchLast(this.array, value, this.contentCompare, this.contentEquals);
   }, SortedArray.prototype.push = function() {
    this.addEach(arguments);
   }, SortedArray.prototype.unshift = function() {
    this.addEach(arguments);
   }, SortedArray.prototype.pop = function() {
    var val = this.array.pop();
    return this.length = this.array.length, val;
   }, SortedArray.prototype.shift = function() {
    var val = this.array.shift();
    return this.length = this.array.length, val;
   }, SortedArray.prototype.slice = function() {
    return this.array.slice.apply(this.array, arguments);
   }, SortedArray.prototype.splice = function(index, length) {
    return this.swap(index, length, Array.prototype.slice.call(arguments, 2));
   }, SortedArray.prototype.swap = function(index, length, plus) {
    if (void 0 === index && void 0 === length) {
     return Array.empty;
    }
    (index = index || 0) < 0 && (index += this.length), void 0 === length && (length = 1 / 0);
    var minus = this.slice(index, index + length);
    return this.dispatchesRangeChanges && this.dispatchBeforeRangeChange(plus, minus, index), 
    this.array.splice(index, length), this.length -= minus.length, this.dispatchesRangeChanges && this.dispatchRangeChange(Array.empty, minus, index), 
    this.addEach(plus), minus;
   }, SortedArray.prototype.reduce = function(callback, basis) {
    var thisp = arguments[2];
    return this.array.reduce(function(basis, value, key) {
     return callback.call(thisp, basis, value, key, this);
    }, basis, this);
   }, SortedArray.prototype.reduceRight = function() {
    var thisp = arguments[2];
    return this.array.reduceRight(function(basis, value, key) {
     return callback.call(thisp, basis, value, key, this);
    }, basis, this);
   }, SortedArray.prototype.min = function() {
    if (this.length) {
     return this.array[0];
    }
   }, SortedArray.prototype.max = function() {
    if (this.length) {
     return this.array[this.length - 1];
    }
   }, SortedArray.prototype.one = function() {
    return this.array.one();
   }, SortedArray.prototype.clear = function() {
    var minus;
    this.dispatchesRangeChanges && (minus = this.array.slice(), this.dispatchBeforeRangeChange(Array.empty, minus, 0)), 
    this.length = 0, this.array.clear(), this.dispatchesRangeChanges && this.dispatchRangeChange(Array.empty, minus, 0);
   }, SortedArray.prototype.equals = function(that, equals) {
    return this.array.equals(that, equals);
   }, SortedArray.prototype.compare = function(that, compare) {
    return this.array.compare(that, compare);
   }, SortedArray.prototype.iterate = function(start, end) {
    return new this.Iterator(this.array, start, end);
   }, SortedArray.prototype.toJSON = function() {
    return this.toArray();
   }, SortedArray.prototype.Iterator = Array.prototype.Iterator;
  }, {
   "./generic-collection": 9,
   "./listen/property-changes": 17,
   "./listen/range-changes": 18,
   "./shim": 28
  } ],
  32: [ function(require, module, exports) {
   "use strict";
   require("./shim");
   var SortedSet = require("./sorted-set"), GenericCollection = require("./generic-collection"), GenericMap = require("./generic-map"), PropertyChanges = require("./listen/property-changes"), MapChanges = require("./listen/map-changes");
   function SortedMap(values, equals, compare, getDefault) {
    if (!(this instanceof SortedMap)) {
     return new SortedMap(values, equals, compare, getDefault);
    }
    equals = equals || Object.equals, compare = compare || Object.compare, getDefault = getDefault || Function.noop, 
    this.contentEquals = equals, this.contentCompare = compare, this.getDefault = getDefault, 
    this.store = new SortedSet(null, function keysEqual(a, b) {
     return equals(a.key, b.key);
    }, function compareKeys(a, b) {
     return compare(a.key, b.key);
    }), this.length = 0, this.addEach(values);
   }
   module.exports = SortedMap, SortedMap.SortedMap = SortedMap, SortedMap.from = GenericCollection.from, 
   Object.addEach(SortedMap.prototype, GenericCollection.prototype), Object.addEach(SortedMap.prototype, GenericMap.prototype), 
   Object.addEach(SortedMap.prototype, PropertyChanges.prototype), Object.addEach(SortedMap.prototype, MapChanges.prototype), 
   Object.defineProperty(SortedMap.prototype, "size", GenericCollection._sizePropertyDescriptor), 
   SortedMap.prototype.constructClone = function(values) {
    return new this.constructor(values, this.contentEquals, this.contentCompare, this.getDefault);
   }, SortedMap.prototype.iterate = function() {
    return this.store.iterate();
   }, SortedMap.prototype.log = function(charmap, logNode, callback, thisp) {
    logNode = logNode || this.logNode, this.store.log(charmap, function(node, log, logBefore) {
     logNode(node.value, log, logBefore);
    }, callback, thisp);
   }, SortedMap.prototype.logNode = function(node, log) {
    log(" key: " + node.key), log(" value: " + node.value);
   };
  }, {
   "./generic-collection": 9,
   "./generic-map": 10,
   "./listen/map-changes": 16,
   "./listen/property-changes": 17,
   "./shim": 28,
   "./sorted-set": 33
  } ],
  33: [ function(require, module, exports) {
   "use strict";
   module.exports = SortedSet;
   require("./shim");
   var GenericCollection = require("./generic-collection"), GenericSet = require("./generic-set"), PropertyChanges = require("./listen/property-changes"), RangeChanges = require("./listen/range-changes"), TreeLog = require("./tree-log");
   function SortedSet(values, equals, compare, getDefault) {
    if (!(this instanceof SortedSet)) {
     return new SortedSet(values, equals, compare, getDefault);
    }
    this.contentEquals = equals || Object.equals, this.contentCompare = compare || Object.compare, 
    this.getDefault = getDefault || Function.noop, this.root = null, this.length = 0, 
    this.addEach(values);
   }
   function Node(value) {
    this.value = value, this.left = null, this.right = null, this.length = 1;
   }
   function Iterator(set, start, end) {
    if (this.set = set, this.prev = null, this.end = end, start) {
     var next = this.set.findLeastGreaterThanOrEqual(start);
     next && (this.set.splay(next.value), this.prev = next.getPrevious());
    }
   }
   SortedSet.SortedSet = SortedSet, Object.addEach(SortedSet.prototype, GenericCollection.prototype), 
   Object.addEach(SortedSet.prototype, GenericSet.prototype), Object.addEach(SortedSet.prototype, PropertyChanges.prototype), 
   Object.addEach(SortedSet.prototype, RangeChanges.prototype), Object.defineProperty(SortedSet.prototype, "size", GenericCollection._sizePropertyDescriptor), 
   SortedSet.from = GenericCollection.from, SortedSet.prototype.isSorted = !0, SortedSet.prototype.constructClone = function(values) {
    return new this.constructor(values, this.contentEquals, this.contentCompare, this.getDefault);
   }, SortedSet.prototype.has = function(value, equals) {
    if (equals) {
     throw new Error("SortedSet#has does not support second argument: equals");
    }
    return !!this.root && (this.splay(value), this.contentEquals(value, this.root.value));
   }, SortedSet.prototype.get = function(value, equals) {
    if (equals) {
     throw new Error("SortedSet#get does not support second argument: equals");
    }
    return this.root && (this.splay(value), this.contentEquals(value, this.root.value)) ? this.root.value : this.getDefault(value);
   }, SortedSet.prototype.add = function(value) {
    var node = new this.Node(value);
    if (!this.root) {
     return this.dispatchesRangeChanges && this.dispatchBeforeRangeChange([ value ], [], 0), 
     this.root = node, this.length++, this.dispatchesRangeChanges && this.dispatchRangeChange([ value ], [], 0), 
     !0;
    }
    if (this.splay(value), !this.contentEquals(value, this.root.value)) {
     var comparison = this.contentCompare(value, this.root.value);
     if (0 === comparison) {
      throw new Error("SortedSet cannot contain incomparable but inequal values: " + value + " and " + this.root.value);
     }
     return this.dispatchesRangeChanges && this.dispatchBeforeRangeChange([ value ], [], this.root.index), 
     comparison < 0 ? (node.right = this.root, node.left = this.root.left, this.root.left = null, 
     this.root.touch()) : (node.left = this.root, node.right = this.root.right, this.root.right = null, 
     this.root.touch()), node.touch(), this.root = node, this.length++, this.dispatchesRangeChanges && this.dispatchRangeChange([ value ], [], this.root.index), 
     !0;
    }
    return !1;
   }, SortedSet.prototype.delete = function(value, equals) {
    if (equals) {
     throw new Error("SortedSet#delete does not support second argument: equals");
    }
    if (this.root && (this.splay(value), this.contentEquals(value, this.root.value))) {
     var index = this.root.index;
     if (this.dispatchesRangeChanges && this.dispatchBeforeRangeChange([], [ value ], index), 
     this.root.left) {
      var right = this.root.right;
      this.root = this.root.left, this.splay(value), this.root.right = right;
     } else {
      this.root = this.root.right;
     }
     return this.length--, this.root && this.root.touch(), this.dispatchesRangeChanges && this.dispatchRangeChange([], [ value ], index), 
     !0;
    }
    return !1;
   }, SortedSet.prototype.indexOf = function(value, index) {
    if (index) {
     throw new Error("SortedSet#indexOf does not support second argument: startIndex");
    }
    return this.root && (this.splay(value), this.contentEquals(value, this.root.value)) ? this.root.index : -1;
   }, SortedSet.prototype.find = function(value, equals, index) {
    if (equals) {
     throw new Error("SortedSet#find does not support second argument: equals");
    }
    if (index) {
     throw new Error("SortedSet#find does not support third argument: index");
    }
    if (this.root && (this.splay(value), this.contentEquals(value, this.root.value))) {
     return this.root;
    }
   }, SortedSet.prototype.findGreatest = function(at) {
    if (this.root) {
     for (at = at || this.root; at.right; ) {
      at = at.right;
     }
     return at;
    }
   }, SortedSet.prototype.findLeast = function(at) {
    if (this.root) {
     for (at = at || this.root; at.left; ) {
      at = at.left;
     }
     return at;
    }
   }, SortedSet.prototype.findGreatestLessThanOrEqual = function(value) {
    if (this.root) {
     return this.splay(value), this.contentCompare(this.root.value, value) > 0 ? this.root.getPrevious() : this.root;
    }
   }, SortedSet.prototype.findGreatestLessThan = function(value) {
    if (this.root) {
     return this.splay(value), this.contentCompare(this.root.value, value) >= 0 ? this.root.getPrevious() : this.root;
    }
   }, SortedSet.prototype.findLeastGreaterThanOrEqual = function(value) {
    if (this.root) {
     return this.splay(value), this.contentCompare(this.root.value, value) >= 0 ? this.root : this.root.getNext();
    }
   }, SortedSet.prototype.findLeastGreaterThan = function(value) {
    if (this.root) {
     return this.splay(value), this.contentCompare(this.root.value, value) <= 0 ? this.root.getNext() : this.root;
    }
   }, SortedSet.prototype.pop = function() {
    if (this.root) {
     var found = this.findGreatest();
     return this.delete(found.value), found.value;
    }
   }, SortedSet.prototype.shift = function() {
    if (this.root) {
     var found = this.findLeast();
     return this.delete(found.value), found.value;
    }
   }, SortedSet.prototype.push = function() {
    this.addEach(arguments);
   }, SortedSet.prototype.unshift = function() {
    this.addEach(arguments);
   }, SortedSet.prototype.slice = function(start, end) {
    start = start || 0, end = end || this.length, start < 0 && (start += this.length), 
    end < 0 && (end += this.length);
    var sliced = [];
    if (this.root) {
     for (this.splayIndex(start); this.root.index < end && (sliced.push(this.root.value), 
     this.root.right); ) {
      this.splay(this.root.getNext().value);
     }
    }
    return sliced;
   }, SortedSet.prototype.splice = function(at, length) {
    return this.swap(at, length, Array.prototype.slice.call(arguments, 2));
   }, SortedSet.prototype.swap = function(start, length, plus) {
    if (void 0 === start && void 0 === length) {
     return [];
    }
    (start = start || 0) < 0 && (start += this.length), void 0 === length && (length = 1 / 0);
    var swapped = [];
    if (this.root) {
     this.splayIndex(start);
     for (var i = 0; i < length; i++) {
      swapped.push(this.root.value);
      var next = this.root.getNext();
      if (this.delete(this.root.value), !next) {
       break;
      }
      this.splay(next.value);
     }
    }
    return this.addEach(plus), swapped;
   }, SortedSet.prototype.splay = function(value) {
    var stub, left, right, temp, root, history;
    if (this.root) {
     for (stub = left = right = new this.Node(), history = new this.Node(), root = this.root; ;) {
      var comparison = this.contentCompare(value, root.value);
      if (comparison < 0) {
       if (!root.left) {
        break;
       }
       if (this.contentCompare(value, root.left.value) < 0 && (temp = root.left, root.left = temp.right, 
       root.touch(), temp.right = root, temp.touch(), !(root = temp).left)) {
        break;
       }
       (temp = new Node()).right = root, temp.left = history.left, history.left = temp, 
       right.left = root, right.touch(), right = root, root = root.left;
      } else {
       if (!(comparison > 0)) {
        break;
       }
       if (!root.right) {
        break;
       }
       if (this.contentCompare(value, root.right.value) > 0 && (temp = root.right, root.right = temp.left, 
       root.touch(), temp.left = root, temp.touch(), !(root = temp).right)) {
        break;
       }
       (temp = new Node()).left = root, temp.right = history.right, history.right = temp, 
       left.right = root, left.touch(), left = root, root = root.right;
      }
     }
     for (left.right = root.left, left.touch(), right.left = root.right, right.touch(), 
     root.left = stub.right, root.right = stub.left; history.left; ) {
      history.left.right.touch(), history.left = history.left.left;
     }
     for (;history.right; ) {
      history.right.left.touch(), history.right = history.right.right;
     }
     root.touch(), this.root = root;
    }
   }, SortedSet.prototype.splayIndex = function(index) {
    if (this.root) {
     for (var at = this.root, atIndex = this.root.index; atIndex !== index; ) {
      if (atIndex > index && at.left) {
       atIndex -= 1 + ((at = at.left).right ? at.right.length : 0);
      } else {
       if (!(atIndex < index && at.right)) {
        break;
       }
       atIndex += 1 + ((at = at.right).left ? at.left.length : 0);
      }
     }
     return this.splay(at.value), this.root.index === index;
    }
    return !1;
   }, SortedSet.prototype.reduce = function(callback, basis, thisp) {
    return this.root && (basis = this.root.reduce(callback, basis, 0, thisp, this)), 
    basis;
   }, SortedSet.prototype.reduceRight = function(callback, basis, thisp) {
    return this.root && (basis = this.root.reduceRight(callback, basis, this.length - 1, thisp, this)), 
    basis;
   }, SortedSet.prototype.min = function(at) {
    var least = this.findLeast(at);
    if (least) {
     return least.value;
    }
   }, SortedSet.prototype.max = function(at) {
    var greatest = this.findGreatest(at);
    if (greatest) {
     return greatest.value;
    }
   }, SortedSet.prototype.one = function() {
    return this.min();
   }, SortedSet.prototype.clear = function() {
    var minus;
    this.dispatchesRangeChanges && (minus = this.toArray(), this.dispatchBeforeRangeChange([], minus, 0)), 
    this.root = null, this.length = 0, this.dispatchesRangeChanges && this.dispatchRangeChange([], minus, 0);
   }, SortedSet.prototype.iterate = function(start, end) {
    return new this.Iterator(this, start, end);
   }, SortedSet.prototype.Iterator = Iterator, SortedSet.prototype.summary = function() {
    return this.root ? this.root.summary() : "()";
   }, SortedSet.prototype.log = function(charmap, logNode, callback, thisp) {
    charmap = charmap || TreeLog.unicodeRound, logNode = logNode || this.logNode, callback || (callback = console.log, 
    thisp = console), callback = callback.bind(thisp), this.root && this.root.log(charmap, logNode, callback, callback);
   }, SortedSet.prototype.logNode = function(node, log, logBefore) {
    log(" " + node.value);
   }, SortedSet.logCharsets = TreeLog, SortedSet.prototype.Node = Node, Node.prototype.reduce = function(callback, basis, index, thisp, tree, depth) {
    if (depth = depth || 0, this.left) {
     var length = this.left.length;
     basis = this.left.reduce(callback, basis, index, thisp, tree, depth + 1), index += length;
    }
    return basis = callback.call(thisp, basis, this.value, index, tree, this, depth), 
    index += 1, this.right && (basis = this.right.reduce(callback, basis, index, thisp, tree, depth + 1)), 
    basis;
   }, Node.prototype.reduceRight = function(callback, basis, index, thisp, tree, depth) {
    return depth = depth || 0, this.right && (basis = this.right.reduceRight(callback, basis, index, thisp, tree, depth + 1), 
    index -= this.right.length), basis = callback.call(thisp, basis, this.value, this.value, tree, this, depth), 
    index -= 1, this.left && (basis = this.left.reduceRight(callback, basis, index, thisp, tree, depth + 1)), 
    basis;
   }, Node.prototype.touch = function() {
    this.length = 1 + (this.left ? this.left.length : 0) + (this.right ? this.right.length : 0), 
    this.index = this.left ? this.left.length : 0;
   }, Node.prototype.checkIntegrity = function() {
    var length = 1;
    if (length += this.left ? this.left.checkIntegrity() : 0, length += this.right ? this.right.checkIntegrity() : 0, 
    this.length !== length) {
     throw new Error("Integrity check failed: " + this.summary());
    }
    return length;
   }, Node.prototype.getNext = function() {
    var node = this;
    if (node.right) {
     for (node = node.right; node.left; ) {
      node = node.left;
     }
     return node;
    }
   }, Node.prototype.getPrevious = function() {
    var node = this;
    if (node.left) {
     for (node = node.left; node.right; ) {
      node = node.right;
     }
     return node;
    }
   }, Node.prototype.summary = function() {
    var value = this.value || "-";
    return value += " <" + this.length, this.left || this.right ? "(" + value + " " + (this.left ? this.left.summary() : "()") + ", " + (this.right ? this.right.summary() : "()") + ")" : "(" + value + ")";
   }, Node.prototype.log = function(charmap, logNode, log, logAbove) {
    var branch, loggedAbove, loggedOn, loggedBelow, self = this;
    branch = this.left && this.right ? charmap.intersection : this.left ? charmap.branchUp : this.right ? charmap.branchDown : charmap.through, 
    this.left && this.left.log(charmap, logNode, function innerWrite(line) {
     loggedAbove ? logAbove(charmap.strafe + " " + line) : (loggedAbove = !0, logAbove(charmap.fromBelow + charmap.through + line));
    }, function innerWriteAbove(line) {
     logAbove("  " + line);
    }), logNode(this, function innerWrite(line) {
     loggedOn ? log((self.right ? charmap.strafe : " ") + line) : (loggedOn = !0, log(branch + line));
    }, function innerWriteAbove(line) {
     logAbove((self.left ? charmap.strafe : " ") + line);
    }), this.right && this.right.log(charmap, logNode, function innerWrite(line) {
     loggedBelow ? log("  " + line) : (loggedBelow = !0, log(charmap.fromAbove + charmap.through + line));
    }, function innerWriteAbove(line) {
     log(charmap.strafe + " " + line);
    });
   }, Iterator.prototype.__iterationObject = null, Object.defineProperty(Iterator.prototype, "_iterationObject", {
    get: function() {
     return this.__iterationObject || (this.__iterationObject = {
      done: !1,
      value: null
     });
    }
   }), Iterator.prototype.next = function() {
    var next;
    return (next = this.prev ? this.set.findLeastGreaterThan(this.prev.value) : this.set.findLeast()) ? void 0 !== this.end && this.set.contentCompare(next.value, this.end) >= 0 ? (this._iterationObject.done = !0, 
    this._iterationObject.value = void 0) : (this.prev = next, this._iterationObject.value = next.value) : (this._iterationObject.done = !0, 
    this._iterationObject.value = void 0), this._iterationObject;
   };
  }, {
   "./generic-collection": 9,
   "./generic-set": 12,
   "./listen/property-changes": 17,
   "./listen/range-changes": 18,
   "./shim": 28,
   "./tree-log": 34
  } ],
  34: [ function(require, module, exports) {
   "use strict";
   function TreeLog() {}
   module.exports = TreeLog, TreeLog.ascii = {
    intersection: "+",
    through: "-",
    branchUp: "+",
    branchDown: "+",
    fromBelow: ".",
    fromAbove: "'",
    fromBoth: "+",
    strafe: "|"
   }, TreeLog.unicodeRound = {
    intersection: "╋",
    through: "━",
    branchUp: "┻",
    branchDown: "┳",
    fromBelow: "╭",
    fromAbove: "╰",
    fromBoth: "┣",
    strafe: "┃"
   }, TreeLog.unicodeSharp = {
    intersection: "╋",
    through: "━",
    branchUp: "┻",
    branchDown: "┳",
    fromBelow: "┏",
    fromAbove: "┗",
    fromBoth: "┣",
    strafe: "┃"
   };
  }, {} ],
  35: [ function(require, module, exports) {
   module.exports = 'undefined' != typeof WeakMap ? WeakMap : require("weak-map");
  }, {
   "weak-map": 36
  } ],
  36: [ function(require, module, exports) {
   !function WeakMapModule() {
    "use strict";
    if ('undefined' == typeof ses || !ses.ok || ses.ok()) {
     'undefined' != typeof ses && (ses.weakMapPermitHostObjects = weakMapPermitHostObjects);
     var doubleWeakMapCheckSilentFailure = !1;
     if ('function' == typeof WeakMap) {
      var HostWeakMap = WeakMap;
      if ('undefined' != typeof navigator && /Firefox/.test(navigator.userAgent)) {} else {
       var testMap = new HostWeakMap(), testObject = Object.freeze({});
       if (testMap.set(testObject, 1), 1 === testMap.get(testObject)) {
        return void (module.exports = WeakMap);
       }
       doubleWeakMapCheckSilentFailure = !0;
      }
     }
     Object.prototype.hasOwnProperty;
     var gopn = Object.getOwnPropertyNames, defProp = Object.defineProperty, isExtensible = Object.isExtensible, HIDDEN_NAME_PREFIX = 'weakmap:', HIDDEN_NAME = HIDDEN_NAME_PREFIX + 'ident:' + Math.random() + '___';
     if ('undefined' != typeof crypto && 'function' == typeof crypto.getRandomValues && 'function' == typeof ArrayBuffer && 'function' == typeof Uint8Array) {
      var ab = new ArrayBuffer(25), u8s = new Uint8Array(ab);
      crypto.getRandomValues(u8s), HIDDEN_NAME = HIDDEN_NAME_PREFIX + 'rand:' + Array.prototype.map.call(u8s, function(u8) {
       return (u8 % 36).toString(36);
      }).join('') + '___';
     }
     if (defProp(Object, 'getOwnPropertyNames', {
      value: function fakeGetOwnPropertyNames(obj) {
       return gopn(obj).filter(isNotHiddenName);
      }
     }), 'getPropertyNames' in Object) {
      var originalGetPropertyNames = Object.getPropertyNames;
      defProp(Object, 'getPropertyNames', {
       value: function fakeGetPropertyNames(obj) {
        return originalGetPropertyNames(obj).filter(isNotHiddenName);
       }
      });
     }
     !function() {
      var oldFreeze = Object.freeze;
      defProp(Object, 'freeze', {
       value: function identifyingFreeze(obj) {
        return getHiddenRecord(obj), oldFreeze(obj);
       }
      });
      var oldSeal = Object.seal;
      defProp(Object, 'seal', {
       value: function identifyingSeal(obj) {
        return getHiddenRecord(obj), oldSeal(obj);
       }
      });
      var oldPreventExtensions = Object.preventExtensions;
      defProp(Object, 'preventExtensions', {
       value: function identifyingPreventExtensions(obj) {
        return getHiddenRecord(obj), oldPreventExtensions(obj);
       }
      });
     }();
     var calledAsFunctionWarningDone = !1, nextId = 0, OurWeakMap = function() {
      this instanceof OurWeakMap || calledAsFunctionWarning();
      var keys = [], values = [], id = nextId++;
      return Object.create(OurWeakMap.prototype, {
       get___: {
        value: constFunc(function get___(key, opt_default) {
         var index, hiddenRecord = getHiddenRecord(key);
         return hiddenRecord ? id in hiddenRecord ? hiddenRecord[id] : opt_default : (index = keys.indexOf(key)) >= 0 ? values[index] : opt_default;
        })
       },
       has___: {
        value: constFunc(function has___(key) {
         var hiddenRecord = getHiddenRecord(key);
         return hiddenRecord ? id in hiddenRecord : keys.indexOf(key) >= 0;
        })
       },
       set___: {
        value: constFunc(function set___(key, value) {
         var index, hiddenRecord = getHiddenRecord(key);
         return hiddenRecord ? hiddenRecord[id] = value : (index = keys.indexOf(key)) >= 0 ? values[index] = value : (index = keys.length, 
         values[index] = value, keys[index] = key), this;
        })
       },
       delete___: {
        value: constFunc(function delete___(key) {
         var index, lastIndex, hiddenRecord = getHiddenRecord(key);
         return hiddenRecord ? id in hiddenRecord && delete hiddenRecord[id] : !((index = keys.indexOf(key)) < 0 || (lastIndex = keys.length - 1, 
         keys[index] = void 0, values[index] = values[lastIndex], keys[index] = keys[lastIndex], 
         keys.length = lastIndex, values.length = lastIndex, 0));
        })
       }
      });
     };
     OurWeakMap.prototype = Object.create(Object.prototype, {
      get: {
       value: function get(key, opt_default) {
        return this.get___(key, opt_default);
       },
       writable: !0,
       configurable: !0
      },
      has: {
       value: function has(key) {
        return this.has___(key);
       },
       writable: !0,
       configurable: !0
      },
      set: {
       value: function set(key, value) {
        return this.set___(key, value);
       },
       writable: !0,
       configurable: !0
      },
      delete: {
       value: function remove(key) {
        return this.delete___(key);
       },
       writable: !0,
       configurable: !0
      }
     }), 'function' == typeof HostWeakMap ? function() {
      function DoubleWeakMap() {
       this instanceof OurWeakMap || calledAsFunctionWarning();
       var dset, hmap = new HostWeakMap(), omap = void 0, enableSwitching = !1;
       return dset = doubleWeakMapCheckSilentFailure ? function(key, value) {
        return hmap.set(key, value), hmap.has(key) || (omap || (omap = new OurWeakMap()), 
        omap.set(key, value)), this;
       } : function(key, value) {
        if (enableSwitching) {
         try {
          hmap.set(key, value);
         } catch (e) {
          omap || (omap = new OurWeakMap()), omap.set___(key, value);
         }
        } else {
         hmap.set(key, value);
        }
        return this;
       }, Object.create(OurWeakMap.prototype, {
        get___: {
         value: constFunc(function dget(key, opt_default) {
          return omap ? hmap.has(key) ? hmap.get(key) : omap.get___(key, opt_default) : hmap.get(key, opt_default);
         })
        },
        has___: {
         value: constFunc(function dhas(key) {
          return hmap.has(key) || !!omap && omap.has___(key);
         })
        },
        set___: {
         value: constFunc(dset)
        },
        delete___: {
         value: constFunc(function ddelete(key) {
          var result = !!hmap.delete(key);
          return omap && omap.delete___(key) || result;
         })
        },
        permitHostObjects___: {
         value: constFunc(function(token) {
          if (token !== weakMapPermitHostObjects) {
           throw new Error('bogus call to permitHostObjects___');
          }
          enableSwitching = !0;
         })
        }
       });
      }
      doubleWeakMapCheckSilentFailure && 'undefined' != typeof Proxy && (Proxy = void 0), 
      DoubleWeakMap.prototype = OurWeakMap.prototype, module.exports = DoubleWeakMap, 
      Object.defineProperty(WeakMap.prototype, 'constructor', {
       value: WeakMap,
       enumerable: !1,
       configurable: !0,
       writable: !0
      });
     }() : ('undefined' != typeof Proxy && (Proxy = void 0), module.exports = OurWeakMap);
    }
    function weakMapPermitHostObjects(map) {
     map.permitHostObjects___ && map.permitHostObjects___(weakMapPermitHostObjects);
    }
    function isNotHiddenName(name) {
     return !(name.substr(0, HIDDEN_NAME_PREFIX.length) == HIDDEN_NAME_PREFIX && '___' === name.substr(name.length - 3));
    }
    function getHiddenRecord(key) {
     if (key !== Object(key)) {
      throw new TypeError('Not an object: ' + key);
     }
     var hiddenRecord = key[HIDDEN_NAME];
     if (hiddenRecord && hiddenRecord.key === key) {
      return hiddenRecord;
     }
     if (isExtensible(key)) {
      hiddenRecord = {
       key: key
      };
      try {
       return defProp(key, HIDDEN_NAME, {
        value: hiddenRecord,
        writable: !1,
        enumerable: !1,
        configurable: !1
       }), hiddenRecord;
      } catch (error) {
       return;
      }
     }
    }
    function constFunc(func) {
     return func.prototype = null, Object.freeze(func);
    }
    function calledAsFunctionWarning() {
     calledAsFunctionWarningDone || 'undefined' == typeof console || (calledAsFunctionWarningDone = !0);
    }
   }();
  }, {} ],
  "/": [ function(require, module, exports) {
   require("./shim");
   var global = (0, eval)('this');
   global.List = require("./list"), global.Set = require("./set"), global.Map = require("./map"), 
   global.MultiMap = require("./multi-map"), global.WeakMap = require("./weak-map"), 
   global.SortedSet = require("./sorted-set"), global.SortedMap = require("./sorted-map"), 
   global.LruSet = require("./lru-set"), global.LruMap = require("./lru-map"), global.SortedArray = require("./sorted-array"), 
   global.SortedArraySet = require("./sorted-array-set"), global.SortedArrayMap = require("./sorted-array-map"), 
   global.FastSet = require("./fast-set"), global.FastMap = require("./fast-map"), 
   global.Dict = require("./dict"), global.Iterator = require("./iterator");
  }, {
   "./dict": 6,
   "./fast-map": 7,
   "./fast-set": 8,
   "./iterator": 13,
   "./list": 14,
   "./lru-map": 19,
   "./lru-set": 20,
   "./map": 21,
   "./multi-map": 22,
   "./set": 23,
   "./shim": 28,
   "./sorted-array": 31,
   "./sorted-array-map": 29,
   "./sorted-array-set": 30,
   "./sorted-map": 32,
   "./sorted-set": 33,
   "./weak-map": 35
  } ]
 }, {}, [])("/");
});